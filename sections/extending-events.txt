<section>
<h2 id="extending-events">扩展事件</h2>


<em>本节内容不是规范的</em>

<h3 id="extending-events-intro">简介</h3>

	本规范定义了数个接口和许多事件，但是，这并不是一组适用所有功能(purposes)
	而面面俱到的(exhaustive)事件集合。为了允许内容作者和实现者添加期望的功能
	(desired functionality)，本规范提供了两种机制来扩展这组接口和事件，
	并且不会产生冲突: <a href="#extending-events-Custom_Events">自定义事件/a> 
	和 <a href="#extending-events-Impl_Extensions">实现特定
	(implementation-specific)的扩展</a> 。

<h3 id="extending-events-Custom_Events">自定义事件</h3>

	脚本作者 <span class="zh-upper">可以</span> 用对应用程序结构(architecture)
	有意义的事件类型来定义功能组件(functional components)方面的应用程序。
	内容作者可以使用 {{CustomEvent}} 接口创建自己的事件，
	这些事件适用于(appropriate to)他们正在使用的抽象(abstraction)层次。

	<div class="example">
		内容作者可能创建了一个应用程序，该应用程序具有动态生成的条形图(bar chart)。
		此条形图应每 5 分钟更新一次，或者当订阅源(feed)显示新信息时，
		或者当用户单击按钮手动刷新时(会额外更新)。当需要更新图表时，
		必须调用数个处理程序(handlers): 应用程序必须获取最新数据，
		向用户显示事件正在更新的图标，并重建图表。要对此进行控制，
		内容作者可以选择创建一个自定义的 <q>updateChart</q> 事件，
		只要满足以上触发(trigger)条件之一，就会触发该事件: 

		<pre><code>
		var chartData = ...;
		var evt = document.createEvent("CustomEvent");
		evt.initCustomEvent( "updateChart", true, false, { data: chartData });
		document.documentElement.dispatchEvent(evt);
		</code></pre>
	</div>

<h3 id="extending-events-Impl_Extensions">实现特定(implementation-specific)
的扩展</h3>

	当一个新事件正在设计和原型化(prototyped)时，或者当一个事件旨在实现特定的功能
	(implementation-specific functionality)时，最好将其与标准化事件区分开来。
	实现 <span class="zh-upper">应当</span> 用一个短字符串作为特定于(specific)
	其实现的事件类型的前缀，以将其与其他实现中的同一事件以及标准化事件区分开来。
	这类似于 CSS 中的
	<a href="http://www.w3.org/TR/CSS21/syndata.html#vendor-keywords" 
		title="CSS 2.1: Syntax and basic data types">供应商特定的(vendor-specific)
	关键字前缀</a> ，可是没有像 CSS 一样使用破折号( <code>"-"</code> )，因为在 
	Javascript 中(破折号)用作属性名称时可能会导致问题。

	<div class="example">
		一个讲究的浏览器供应商 <q>FooCorp</q> 预期希望推出一个新的事件 
		<code class="eventtype">jump</code> 。这家供应商在他们的浏览器中实现了
		<code class="eventtype">fooJump</code> ，使用他们的供应商特定的前缀: 
		<code>"foo"</code> 。早期(新技术)应用者开始使用 
		<code>someElement.addEventListener("fooJump", doJump, false)</code> 
		来试验该事件，并向 FooCorp 提供反馈， FooCorp 会相应地更改
		<code class="eventtype">fooJump</code> 的行为。

		一段时间后，另一家供应商 <q>BarOrg</q> 决定他们也想要该功能，
		但实现方式略有不同，因此他们在事件类型名称中使用自己的供应商特定的前缀 
		<code>"bar"</code>: <code class="eventtype">barJump</code> 。
		试验此版本的 <code class="eventtype">jump</code> 事件类型的内容作者使用 
		BarOrg 的事件类型名称注册事件。希望编写适用于两种浏览器的代码的内容作者，
		可以使用特定的事件处理程序分别注册每个事件类型，
		也可以使用同一个事件处理程序并根据事件类型的名称执行不同的操作。因此，
		不同代码库中的早期试验不会发生冲突，并且早期(新技术)
		应用者能够为多个实现编写易于维护(easily-maintained)的代码。

		最终，随着功能的成熟，两种浏览器的行为都会稳定下来，
		并可能会因为内容作者和用户的反馈或通过正式的标准化而趋同。
		随着这种稳定化的发生，冲突的风险降低，内容作者可以删除分叉(forked)代码，
		并使用相同的事件处理程序和更通用的注册方法 
		<code>someElement.addEventListener( "jump", doJump, false)</code> 
		(甚至在正式标准化之前)去使用 <code class="eventtype">jump</code> 
		事件类型名称。
	</div>

	<h4 id="extending-events-prefixes">已知的实现特定的前缀</h4>

		在撰写本规范时，已知存在以下事件类型名称前缀: 

		++---------------------+------------+-----------------------+
		=| 前缀                | 引擎内核   | 供应商(Organization)  |
		 +---------------------+------------+-----------------------+
		+| <code>moz</code>,   | Gecko      | Mozilla               |
		 | <code>Moz</code>    |            |                       |
		+| <code>ms</code>,    | Trident    | Microsoft             |
		 | <code>MS</code>     |            |                       |
		+| <code>o</code>,     | Presto     | Opera Software        |
		 | <code>O</code>      |            |                       |
		+| <code>webkit</code> | WebKit     | Apple, Google, others |
		++---------------------+------------+-----------------------+

		<div class="note custom-note">
		需要说明的是，浏览器事件目前(2023年6月12日)已经趋同，
		已经很少见到实现特定的扩展事件了，原始规范的 <q>在撰写本文时</q> 的 
		github 提交的记录信息是 <q>Gary Kacmarcik, 7年前 (3 5th, 2016 1:56 凌晨)</q>
		。不过这个表格中的前缀列对老版本浏览器的实现特定的 CSS 
		属性前缀的使用理解有帮助。
		</div>

</section>
