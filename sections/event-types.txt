<section>
<h2 id="event-types">事件类型</h2>


DOM 事件模型允许 DOM 实现支持多个事件模块。
该模型的设计允许将来添加新的事件模块(可扩展)。本文档没有试图定义所有可能的事件。
为了实现互操作性(interoperability)，
DOM 定义了一个用户界面事件模块(包括较低级别的设备独立事件)和一个文档变化事件
(document mutation events)模块。

<h3 id="events-uievents">用户界面事件</h3>
	用户界面事件模块包含与用户界面和文档操作相关联的基本事件类型。
	
	<h4 id="interface-uievent">UIEvent 接口</h4>
	
		<p class="intro-dom">在 DOM Level 2中引入介绍</p>
	
		{{UIEvent}} 接口提供了与用户界面事件相关的特定上下文信息。
	
		要创建 {{UIEvent}} 接口的实例，使用UIEvent构造函数，
		传递一个可选的 {{UIEventInit}} 字典。
	
		<p class="note">
		对于新定义的事件，你不必继承 {{UIEvent}} 接口，因为它们与用户界面相关。
		只有当 {{UIEventInit}} 的成员对那些事件有意义时才继承。
		</p>
	
		<h5 id="idl-uievent">UIEvent</h5>
	
			<pre class="idl">
			[Exposed=Window]
			interface UIEvent : Event {
				constructor(DOMString type, optional UIEventInit eventInitDict = {});
				readonly attribute Window? view;
				readonly attribute long detail;
			};
			</pre>
	
			<dl>
				<dt><code>UIEvent . view</code></dt>
				<dd>
					<code>view</code> 属性标识生成事件的窗口 <code>Window</code> 。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是 <code>null</code> 。
				</dd>
	
				<dt><code>UIEvent . detail</code></dt>
				<dd>
					指定有关 {{Event}} 的一些详细信息，具体取决于事件的类型。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>0</code> 。
					
					<p class="note custom-note">
						<code>UIEvent.detail</code> ，只读属性，返回一个数字，当值为非零时，
						根据具体的事件类型返回点击次数: <br/>
						① 对于 <a href="#event-type-click"><code>click</code></a>
						和 <a href="#event-type-dblclick"><code>dblclick</code></a> 事件
						，<code>UIEvent.detail</code> 返回当前点击数; <br/>
						② 对于 <a href="#event-type-mousedown"><code>mousedown</code></a> 
						和 <a href="#event-type-mouseup"><code>mouseup</code></a> 事件
						， <code>UIEvent.detail</code> 是 <code>1</code> 加上当前点击数; 
						<br/>
						③ 对于其它 {{UIEvent}} 事件，<code>UIEvent.detail</code> 
						一直是 <code>0</code> 。
					</p>
				</dd>
			</dl>
	
		<h5 id="idl-uieventinit">UIEventInit</h5>
	
			<pre class="idl">
			dictionary UIEventInit : EventInit {
				Window? view = null;
				long detail = 0;
			};
			</pre>
	
			<dl>
				<dt><code>UIEventInit . view</code></dt>
				<dd>
					应初始化为全局环境的Window对象，该事件将在这个Window对象中派发。
					如果这个事件将被派发到一个元素，view属性应该设置为包含改元素的
					<code>ownerDocument</code> 的Window对象。
				</dd>
	
				<dt><code>UIEventInit . detail</code></dt>
				<dd>
					此属性的初始化值为数字，取决于应用程序(application-specific)。
				</dd>
			</dl>
	
	<h4 id="events-uievent-types">用户界面事件类型</h4>
	
		用户界面事件类型列表如下所示。如果事件从用户界面生成，
		那么这些些事件使用 {{UIEvent}} 接口实现，
		否则使用 {{Event}} 接口实现，详见每个事件。
	
		<h5 id="event-type-load"><dfn>load</dfn></h5>
	
      ++------------------+--------------------------------------------------------------------------------------+ event-definition
      =| %                |                                                                                      |
       +------------------+--------------------------------------------------------------------------------------+
      +| 类型             | <strong><code>load</code></strong>                                                   |
      +| 接口             | 事件从用户界面生成就是 {{UIEvent}}，否则是 {{Event}} 。                              |
      +| 同步 / 异步      | 异步                                                                                 |
      +| 冒泡             | 不                                                                                   |
      +| 可信目标对象     | <a><code>Window</code></a>, <code>Document</code>, <code>Element</code>              |
      +| 可取消默认行为   | 不                                                                                   |
      +| 默认行为         | 没有                                                                                 |
      +| 上下文 <br/>     | <ul>                                                                                 |
       | (可信事件)       | <li>{{Event}}.{{Event/target}} : 已加载其所含资源的普通对象</li>                     |
       |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
       |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
       |                  | </ul>                                                                                |
      ++------------------+--------------------------------------------------------------------------------------+
	
			当DOM实现(DOM implementation)完成对资源(如文档)和所有的依赖资源
			(如图像，样式表或脚本)的加载后，
			<a href="#user-agent">用户代理</a> 必须派发这个 <code>load</code> 事件。
			如果加载依赖资源的元素(如&lt;link&gt;，&lt;script&gt;)
			仍然可以通过DOM访问，那么加载失败的依赖资源
			<span class="zh-upper">绝对不能</span> 阻止此事件的触发。
			派发此事件的事件对象 <span class="zh-upper">被要求</span> 
			至少是在 <code>Document</code> 节点上。

			<p class="note">
			由于遗留的原因，在HTML实现的传播路径(事件流)中，
			文档内资源(例如，图像)的 EVENT{load} 事件不包括
			<a href="#window">Window</a> 。
			更多信息请参见[[HTML5]]。
			</p>

		<h5 id="event-type-unload"><dfn>unload</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>unload</code></strong>                                                 |
			+| 接口             | 事件从用户界面生成就是 {{UIEvent}}，否则是 {{Event}} 。                              |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 不                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Document</code>, <code>Element</code>              |
			+| 可取消默认行为   | 不                                                                                   |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 已加载资源的普通对象</li>                           |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当用户代理从环境中移除资源(如文档)或任何依赖资源(如图像，样式表，脚本)时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 派发 <code>unload</code> 事件。
			DOM文档在派发 <code>unload</code> 事件后 <span class="zh-upper">必须</span> 被卸载(unloaded)。
			和 <code>load</code> 事件一样，派发此事件的事件对象 <span class="zh-upper">被要求</span> 至少是 <code>Document</code> 节点。
	
		<h5 id="event-type-abort"><dfn>abort</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>abort</code></strong>                                                  |
			+| 接口             | 由用户界面产生就是 {{UIEvent}} ，否则为 {{Event}} 。                                 |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 不                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 不                                                                                   |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 资源已被停止加载而没有出错的元素</li>               |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当资源的加载被中止时，例如用户在加载仍在进行时取消加载，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 派发此事件。
	
		<h5 id="event-type-error"><dfn>error</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>error</code></strong>                                                  |
			+| 接口             | 由用户界面产生就是 {{UIEvent}} ，否则为 {{Event}} 。                                 |
			+| 同步 / 异步      | 异步                                                                                 |
			+| 冒泡             | 不                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 不能                                                                                 |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 由于错误而停止加载其资源的元素</li>                 |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当资源加载失败或已加载但无法根据其语义进行解释时，
			例如无效图像、脚本执行错误或格式不正确的XML，
			<a href="#user-agent"> 用户代理 </a> <span class="zh-upper">必须</span> 派发 <code>error</code> 事件。
	
		<h5 id="event-type-select"><dfn>select</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>select</code></strong>                                                 |
			+| 接口             | 由用户界面产生就是 {{UIEvent}} ，否则为 {{Event}} 。                                 |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 是                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 不能                                                                                 |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 已选择其文本内容的元素</li>                         |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当用户选择某些文本时， <a href="#user-agent">用户代理</a>
			必须调度此事件。此事件是在选择发生后发出的。
	
			本规范不提供访问所选文本的上下文信息。在应用此事件的情况下，
			<a href="#host-language">宿主语言</a> <span class="zh-upper">应</span> 定义用户 
			<span class="zh-upper">可以</span> 如何选择内容(考虑国际语言惯例)、
			在什么时候派发 EVENT{select} 事件以及内容作者 <span class="zh-upper">可以</span> 
			如何访问用户选择的内容的规则。
	
			<p class="note">
			为了访问用户选择的内容，内容作者将使用 <a href="#host-language">宿主语言</a> 的本地功能，
			例如HTML Editing API [[Editing]] 的 <code>Document.getSelection()</code> 方法。
			</p>
	
			<p class="note">
			EVENT{select} 事件可能不适用于所有语言的所有元素。
			例如，在 [[HTML5]] 中， EVENT{select} 事件只能在表单 <{input}> 和 <{textarea}> 元素上派发。
			实现可以在任何被认为合适的上下文中派发 EVENT{select}，
			包括表单控件之外的文本选择，或者SVG中的图像或标记选择。
			</p>

<h3 id="events-focusevent">焦点事件</h3>
	<p class="note">
	该接口及其关联的事件类型和
	[[#events-focusevent-event-order]]
	是根据 <a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/">
	用户代理可访问性指南2.0</a> [[UAAG20]] 中定义的概念和指南设计的，需要特别关注
	<a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/#gl-focus-mechanism">
	焦点机制</a> 和 
	<a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/#def-focus">
	焦点术语表条目</a> 中定义的术语。
	</p>
	
	<h4 id="interface-focusevent">FocusEvent 接口</h4>
	
		<p class="intro-dom">在本规范中引入介绍</p>
	
		{{FocusEvent}} 接口提供了与Focus事件相关的特定上下文信息。

		要创建 {{FocusEvent}} 接口的实例，使用 <code>FocusEvent</code> 构造函数，传递一个可选的 {{FocusEventInit}} 字典。
	
		<h5 id="idl-focusevent">FocusEvent</h5>
	
			<pre class="idl">
			[Exposed=Window]
			interface FocusEvent : UIEvent {
				constructor(DOMString type, optional FocusEventInit eventInitDict = {});
				readonly attribute EventTarget? relatedTarget;
			};
			</pre>
	
			<dl>
				<dt><code>FocusEvent . relatedTarget</code></dt>
				<dd>
					用于标识与Focus事件相关的次要 {{EventTarget}}，具体取决于事件的类型。

					出于嵌套浏览上下文的安全考虑，当进入或退出嵌套上下文时，
					相关的 {{EventTarget}} <span class="zh-upper">应当</span> 为 <code>null</code> 。

					此属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 为 <code>null</code> 。
				</dd>
			</dl>
	
		<h5 id="idl-focuseventinit">FocusEventInit</h5>
	
			<pre class="idl">
			dictionary FocusEventInit : UIEventInit {
				EventTarget? relatedTarget = null;
			};
			</pre>
	
			<dl>
				<dt><code>FocusEventInit . relatedTarget</code></dt>
				<dd>
					应该将 {{FocusEventInit/relatedTarget}} 初始化为失去焦点的元素
					(在 EVENT{focus} 或 EVENT{focusin} 事件的情况下)或获得焦点的元素
					(在 EVENT{blur} 或 EVENT{focusout}事件的情况下)。
				</dd>
			</dl>
	
	<h4 id="events-focusevent-event-order">焦点事件顺序</h4>
	
		本规范中定义的焦点事件以相对于另一个焦点事件的固定顺序发生。
		以下是焦点在元素之间转移时的典型事件序列(此顺序假设最初没有元素被聚焦):
	
		++---+------------+----------------------------------------------------+
		=| # | 事件类型   | 注释                                               |
		 +---+------------+----------------------------------------------------+
		+|   |            | <em>用户转移焦点</em>                              |
		+| 1 | focus      | 在第一个目标元素接收焦点之后发送                   |
		+| 2 | focusin    | 紧随 focus 事件发送                                |
		+|   |            | <em>用户转移焦点</em>                              |
		+| 3 | blur       | 在第一个目标元素失去焦点之后发送                   |
		+| 4 | focusout   | 紧随 blur 事件发送                                 |
		+| 5 | focus      | 在第二个目标元素接收焦点后发送                     |
		+| 6 | focusin    | 紧随 focus 事件发送                                |
		++---+------------+----------------------------------------------------+
	
		<p class="note">
		该规范没有定义焦点事件在与 <code>focus()</code> 或 <code>blur()</code> 
		等方法交互时的行为。请参阅相关规范，其中为此类行为定义了这些方法。
		</p>
	
	<h4 id="events-focusevent-doc-focus">文档焦点和焦点上下文</h4>
	
		此事件模块包括用于通知文档 <a href="#focus">焦点</a> 发生变更的事件类型。
		有三个不同的焦点上下文与这个讨论相关: 
	
		*	<em>操作系统焦点上下文</em> ，可能是当前在计算机上运行的许多不同应用程序中的一个。
			这些重点应用程序之一可以是浏览器。
	
		*	当浏览器获得焦点后，用户可以在不同的浏览器用户界面字段
			(例如，Web站点位置栏、搜索字段等)之间切换(例如，使用tab键) <em>应用程序焦点上下文</em> 。
			这些用户界面字段之一可以是在选项卡中显示的文档。
	
		*	当文档本身具有焦点时，可以将 <em>文档焦点上下文</em> 设置为文档中任何可聚焦的元素。

		本规范中定义的事件类型专门处理文档焦点(而不是操作系统焦点和应用程序焦点)，
		在事件详细信息中标识的 <a href="#event-target">事件目标</a> 
		<span class="zh-upper">必须</span> 只能是文档或窗口中的文档的一部分，
		而不能是浏览器或操作系统的一部分，
		即使是从一个焦点上下文切换到另一个焦点上下文时也是如此。
	
		通常，文档总是有一个焦点元素(即使它本身就是文档元素)和一个持久的
		<a href="#focus-ring">焦点环</a> 。在焦点上下文之间切换时，
		文档的当前焦点元素和焦点环通常保持当前状态。例如，
		如果一个文档有三个可聚焦的元素，其中第二个元素是聚焦的，
		当用户将操作系统焦点更改为另一个应用程序，然后再更改为浏览器时，
		第二个元素仍将在文档中聚焦，而选项卡将把焦点更改为第三个元素。
		<a href="#host-language">宿主语言</a> <span class="zh-upper">可以</span>
		定义可以接收焦点的特定元素、元素 <span class="zh-upper">可以</span> 
		接收焦点的条件、 <span class="zh-upper">可以</span> 改变焦点的方式
		以及焦点改变(发生事件)的顺序。例如，在某些情况下，
		可以通过将指针移到元素上来获得焦点，而在其他情况下可能需要单击鼠标。
		有些元素可能根本无法成为焦点，有些元素可能只能通过特殊方式
		(单击元素) 变成可聚焦的元素，但不能通过按下 <code>tab</code> 键聚焦它。
		文档 <span class="zh-upper">可以</span> 包含多个焦点环。
		其他规范 <span class="zh-upper">可以</span> 
		定义比本规范中描述的更复杂的焦点模型，包括允许多个元素具有当前焦点。
	
	<h4 id="events-focus-types">焦点事件类型</h4>
	
		下面列出了焦点事件类型。
	
		<h5 id="event-type-blur"><dfn>blur</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>blur</code></strong>                                                   |
			+| 接口             | {{FocusEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 不                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 不                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 失去焦点的                                          |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} : 接收焦点的                         |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当 <a href="#event-target">事件目标</a> 失去焦点后，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。在派发此事件之前，元素(失去焦点的事件目标)
			<span class="zh-upper">必须</span> 被取下焦点。此类型类似于 
			EVENT{focusout} ，并且会发生冒泡。
	
		<h5 id="event-type-focus"><dfn>focus</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>focus</code></strong>                                                  |
			+| 接口             | {{FocusEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 不                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 不                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 接收焦点的                                          |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} : 失去焦点的                         |
			 |                  |     <a href="#event-target">事件目标</a> (如果有的话)。</li>                         |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当 <a href="#event-target">事件目标</a> 接收焦点后，
			<a href="#user-agent">用户代理</a>， <span class="zh-upper">必须</span> 
			派发此事件。在派发此事件之前， <span class="zh-upper">必须</span> 
			将焦点放在元素(接收焦点的事件目标)上。此事件类型类似于 
			EVENT{focusin} ，并且不会发生冒泡。
	
		<h5 id="event-type-focusin"><dfn>focusin</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>focusin</code></strong>                                                |
			+| 接口             | {{FocusEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 即将接收焦点的                                      |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} : 即将失去焦点的                     |
			 |                  |     <a href="#event-target">事件目标</a> (如果有的话)。</li>                         |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当 <a href="#event-target">事件目标</a> 接收焦点后， 
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。<a href="#event-target">事件目标</a> 
			<span class="zh-upper">必须</span> 是即将接收焦点的元素。EVENT{focus} 事件
			<span class="zh-upper">必须</span> 在此事件类型派发前发送。
			此事件类型类似于 EVENT{focus} ，并且发生冒泡。
	
		<h5 id="event-type-focusout"><dfn>focusout</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>focusout</code></strong>                                               |
			+| 接口             | {{FocusEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <a><code>Window</code></a>, <code>Element</code>                                     |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 即将失去焦点的                                      |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} : 即将接收焦点的                     |
			 |                  |     <a href="#event-target">事件目标</a> </li>                                       |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当 <a href="#event-target">事件目标</a> 失去焦点后，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。<a href="#event-target">事件目标</a>
			<span class="zh-upper">必须</span> 是即将失去焦点的元素。 EVENT{blur} 事件 
			<span class="zh-upper">必须</span> 在此事件类型派发前发送。
			此事件类型类似于 EVENT{blur} ，并且发生冒泡。

<h3 id="events-mouseevents">鼠标事件</h3>
	鼠标事件模块来源于 [[HTML401]] 定义的<code>onclick</code>,
	<code>ondblclick</code>, <code>onmousedown</code>, <code>onmouseup</code>,
	<code>onmouseover</code>, <code>onmousemove</code>, 和
	<code>onmouseout</code> 属性。鼠标事件模块专门为指向输入设备
	(pointing input devices)设计使用(designed for use)，例如鼠标或轨迹球。
	
	<h4 id="interface-mouseevent">MouseEvent 接口</h4>
	
		<p class="intro-dom">
		在DOM Level 2中引入介绍，并在本规范修改调整
		</p>

		{{MouseEvent}} 接口提供了与鼠标事件相关的特定上下文信息

		在有嵌套元素的场景下，鼠标事件总是把嵌套最深的元素作为目标。
	
		<p class="note">
		目标元素的祖先可以利用事件冒泡来获取其派生元素中发生的鼠标事件的通知。
		</p>
	
		要创建 {{MouseEvent}} 接口的实例，请使用 {{MouseEvent}} 构造函数，
		它接收一个可选的 {{MouseEventInit}} 字典作为初始化事件的参数。
	
		<p class="note">
		当使用 <code>initMouseEvent</code> 初始化 {{MouseEvent}} 对象时，
		(浏览器)实现可以使用客户端坐标 {{MouseEvent/clientX}} 和 
		{{MouseEvent/clientY}} 来计算其他坐标(例如 
		<a href="#dom-level-0">DOM Level 0</a> 实现公开了目标坐标或其他私有属性，
		见于 <code>pageX</code> <code>pageY</code> 等)。
		</p>
	
		<h5 id="idl-mouseevent">MouseEvent</h5>
	
			<pre class="idl">
			[Exposed=Window]
			interface MouseEvent : UIEvent {
				constructor(DOMString type, optional MouseEventInit eventInitDict = {});
				readonly attribute long screenX;
				readonly attribute long screenY;
				readonly attribute long clientX;
				readonly attribute long clientY;
	
				readonly attribute boolean ctrlKey;
				readonly attribute boolean shiftKey;
				readonly attribute boolean altKey;
				readonly attribute boolean metaKey;
	
				readonly attribute short button;
				readonly attribute unsigned short buttons;
	
				readonly attribute EventTarget? relatedTarget;
	
				boolean getModifierState(DOMString keyArg);
			};
			</pre>
	
			<dl dfn-for="MouseEvent">
				<dt	class="origin-dfn"><dfn attribute>screenX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">screenX</code></i>，
					<code>long</code>
					<span class="replacement"> 类型(4字节整型)，只读</span>
				</dt>
				<dd>
					事件发生时相对于屏幕坐标系原点的水平坐标。

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>screenY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">screenY</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，只读</span>
				</dt>
				<dd>
					事件发生时相对于屏幕坐标系原点的竖直坐标。

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>clientX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">clientX</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，只读</span>
				</dt>
				<dd>
					提供了发生事件的位置在应用程序视口中的水平坐标(而不是可能滚动的页面的坐标)。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>clientY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">clientY</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，只读</span>
				</dt>
				<dd>
					提供了发生事件的位置在应用程序视口中的竖直坐标(而不是可能滚动的页面的坐标)。

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>ctrlKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">ctrlKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，只读</span>
				</dt>
				<dd>
					请参阅 {{KeyboardEvent}} 的 {{KeyboardEvent/ctrlKey}} 属性。
					<p class="note custom-note">
						{{KeyboardEvent/ctrlKey}} 属性提供了当触发的鼠标事件发生时，
						<code>ctrl</code> 键修饰符是否活跃的状态
					</p>
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>false</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>shiftKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">shiftKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，只读</span>
				</dt>
				<dd>
					请参阅 {{KeyboardEvent}} 的 {{KeyboardEvent/shiftKey}} 属性。

					<p class="note custom-note">
						{{KeyboardEvent/shiftKey}} 属性提供了当触发的鼠标事件发生时，
						<code>ctrl</code> 键修饰符是否活跃的状态
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>false</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>altKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">altKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，只读</span>
				</dt>
				<dd>
					请参阅 {{KeyboardEvent}} 的 {{KeyboardEvent/altKey}} 属性。
					
					<p class="note custom-note">
						{{KeyboardEvent/altKey}} 属性提供了当触发的鼠标事件发生时，
						<code>ctrl</code> 键修饰符是否活跃的状态
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>false</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>metaKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">metaKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，只读</span>
				</dt>
				<dd>
					请参阅 {{KeyboardEvent}} 的 {{KeyboardEvent/metaKey}} 属性。
					
					<p class="note custom-note">
						{{KeyboardEvent/metaKey}} 属性提供了当触发的鼠标事件发生时，
						<code>ctrl</code> 键修饰符是否活跃的状态
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>false</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>button</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">button</code></i>，
					<code>short</code> 
					<span class="replacement"> 类型(2字节整型)，只读</span>
				</dt>
				<dd>
					在按下或释放鼠标按钮引起的鼠标事件中， <span class="zh-upper">必须</span> 
					使用 {{MouseEvent/button}} 来指示指针设备的哪个按键改变了状态。
	
					{{MouseEvent/button}} 属性的值 
					<span class="zh-upper">必须</span> 如下所示: 
	
					*	<code>0</code> <span class="zh-upper">必须</span> 表示设备的主按键
						(一般而言是左按键或单按键设备上的唯一按键，用于激活用户界面控件或选择文本)
						或 表示未初始化的值。
					*	<code>1</code> <span class="zh-upper">必须</span> 表示设备的辅助(auxiliary)按键
						(一般而言是中间按键，并与鼠标滚轮组合)。
					*	<code>2</code> <span class="zh-upper">必须</span> 表示设备的次(secondary)按键
						(一般而言是右按键，通常用于显示一个上下文菜单)。
					*	<code>3</code> <span class="zh-upper">必须</span> 表示设备的X1(后退)按键
						(第4按键，常用于浏览器后退按键)。
					*	<code>4</code> <span class="zh-upper">必须</span> 表示设备的X2(前进)按键
						(第5按键，常用于浏览器前进按键)

					一些定位设备提供或模拟更多的按键状态，并且 <span class="zh-upper">可以</span> 使用高于 
					<code>2</code> 或低于 <code>0</code> 的值来表示这样的按键状态。
	
					<p class="note">
					对于不是由按下/释放鼠标按键引起的事件， {{MouseEvent/button}} 的值不会更新。
					在这些场景中，请注意不要将值 <code>0</code> 解释为左按键的激活状态，而是将其解释为
					<a href="#un-initialized-value">未初始化值</a>  。
					</p>
	
					<p class="note">
					一些与 EVENT{mousedown} 和 EVENT{mouseup} 
					等事件相关的 <a href="#default-action">默认操作</a> 
					取决于触发事件的特定鼠标按键。
					</p>

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>buttons</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">buttons</code></i>，
					<code>unsigned short</code> 
					<span class="replacement"> 类型(无符号2字节整型)，只读</span>
				</dt>
				<dd>
					在任何鼠标事件触发期间， <span class="zh-upper">必须</span> 
					使用 {{MouseEvent/buttons}} 来指示当前设备正被按下的鼠标按键组合，以位掩码表示。
	
					<p class="note">
					虽然名称相似，但 {{MouseEvent/buttons}} 属性和 {{MouseEvent/button}} 
					属性的值非常不同。
					在 EVENT{mousedown} / EVENT{mouseup} 事件处理程序中， {{MouseEvent/button}} 
					的值被认为是有效的，而 {{MouseEvent/buttons}} 属性反映了任何可信的
					{{MouseEvent}} 对象(在事件被派发时)的鼠标按键的状态，因此它能表示
					"当前没有活动的按键"这一状态({{MouseEvent/buttons}} 属性值为 <code>0</code> 时)。
					</p>
	
					{{MouseEvent/buttons}} 属性的值 <span class="zh-upper">必须</span> 是如下所示
					(组成的位掩码): 
	
					*	<code>0</code> <span class="zh-upper">必须</span> 表示当前没有按键被激活

						<p class="note custom-note">
							按键激活就是按键处于按下状态，下同理
						</p>

					*	<code>1</code> <span class="zh-upper">必须</span> 表示设备的主按键处于激活状态
						(一般而言，设备的主按键是左按键或单按键设备上的唯一按键，用于激活用户界面控件或选择文本)。
					*	<code>2</code> <span class="zh-upper">必须</span> 表示次按键(如果存在)处于激活状态
						(一般而言，设备的次按键是右按键，通常用于显示一个上下文菜单)。
					*	<code>4</code> <span class="zh-upper">必须</span> 表示辅助按键处于激活状态
						(一般而言是中间按键，并与鼠标滚轮组合)。
	
					一些定位设备能提供或模拟更多按键。为了表示这些按键，每个连续按钮的值 
					<span class="zh-upper">必须</span> 增长一倍(也就是在二进制序列 <code>8</code> ，
					<code>16</code> ， <code>32</code> ，...)。
	
					<p class="note">
					因为任何一组按键值的总和(与操作)都是一个唯一的数字，
					所以对于一个拥有任意数量的鼠标按键的设备而言，
					开发者可以使用逐位(遍历)操作来确定当前被按下的按钮数量，
					以及它们是哪些按键。例如，值 <code>3</code> 
					表示当前同时按下了左按键和右按键，而值 <code>5</code> 
					表示当前同时按住了左按键和中间按键。
	
					<p class="note">
					一些与 EVENT{mousedown} 和 EVENT{mouseup} 
					等事件相关的 <a href="#default-action">默认操作</a> 
					取决于使用中的特定鼠标按键。
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>relatedTarget</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">relatedTarget</code></i>，
					<code>EventTarget</code> 
					<span class="replacement"> 类型，只读，可空</span>
				</dt>
				<dd>
					用于标识与 UI 事件相关的次要 {{EventTarget}}，具体值取决于事件的类型。
					
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>null</code> 。
				</dd>
	
				<dt><dfn method>getModifierState(keyArg)</dfn></dt>
				<dd>
					<p class="intro-dom">(该方法)在本规范中引入介绍</p>
	
					使用键值查询(键盘按键)修饰符的状态。

					如果它(传入的 <code>keyArg</code> )是一个 (键盘) 修饰符键并且对应的按键被激活，
					则返回 <code>true</code> ，否则返回 <code>false</code> 。
	
					<dl class="parameters">
						<dt>DOMString keyArg</dt>
						<dd>
							有关此参数的描述，请参阅 {{KeyboardEvent}} 的 {{KeyboardEvent/getModifierState()}} 方法。
						</dd>
					</dl>
				</dd>
			</dl>
	
		<h5 id="idl-mouseeventinit">MouseEventInit</h5>
	
			<pre class="idl">
			dictionary MouseEventInit : EventModifierInit {
				long screenX = 0;
				long screenY = 0;
				long clientX = 0;
				long clientY = 0;
	
				short button = 0;
				unsigned short buttons = 0;
				EventTarget? relatedTarget = null;
			};
			</pre>
	
			<dl dfn-for="MouseEventInit">
				<dt class="origin-dfn"><dfn dict-member>screenX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">screenX</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，
					默认值为 <code>0</code> 
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/screenX}} 
					属性初始化为鼠标指针在用户屏幕上期望的水平相对位置。
	
					将事件对象的 {{MouseEvent/screenX}} 属性初始化为给定的鼠标位置时，
					不得将用户的鼠标指针移动到初始化位置。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>screenY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">screenX</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，
					默认值为 <code>0</code> </span>
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/screenY}} 
					属性初始化为鼠标指针在用户屏幕上期望的竖直相对位置。

					将事件对象的 {{MouseEvent/screenY}} 属性初始化为给定的鼠标位置时，
					不得将用户的鼠标指针移动到初始化位置。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>clientX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">clientX</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，
					默认值为 <code>0</code> </span>
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/clientX}} 
					属性初始化为鼠标指针相对于用户浏览器的客户端窗口(视口)期望的水平位置。
	
					将事件对象的 {{MouseEvent/clientX}} 属性初始化为给定的鼠标位置时，
					不得将用户的鼠标指针移动到初始化位置。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>clientY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">clientY</code></i>，
					<code>long</code> 
					<span class="replacement"> 类型(4字节整型)，
					默认值为 <code>0</code> </span>
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/clientY}} 
					属性初始化为鼠标指针相对于用户浏览器的客户端窗口(视口)期望的竖直位置。
	
					将事件对象的 {{MouseEvent/clientY}} 属性初始化为给定的鼠标位置时，
					不得将用户的鼠标指针移动到初始化位置。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>button</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">button</code></i>，
					<code>short</code> 
					<span class="replacement"> 类型(2字节整型)，
					默认值为 <code>0</code> </span>
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/button}} 
					属性初始化为一个数字，这个数字表示鼠标按键期望的状态。
	
					<p class="note">
					值 0 用于表示鼠标主按键，值 1 用于表示辅助按键/鼠标中键，值 2 
					用于表示鼠标右键。大于 2 的数字也是可能的，但在本文档中没有指定规范。
					</p>
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>buttons</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">buttons</code></i>，
					<code>unsigned short</code> 
					<span class="replacement"> 类型(无符号2字节整型)，
					默认值为 <code>0</code> </span>
				</dt>
				<dd>
					将 {{MouseEvent}} 对象的 {{MouseEvent/buttons}} 属性初始化为一个数字，
					该数字表示鼠标的一个 <em>或多个</em> 按键处于激活状态。
	
					<p class="note">
					{{MouseEvent/buttons}} 属性是一个位字段(bit-field)。
					如果将掩码值 <code>1</code> 和位字段的值(也就是 {{MouseEvent/buttons}} 
					属性值)进行与操作结果为 <code>true</code> (或者说是 <code>1</code> )，
					则表示(事件触发时)鼠标左键(主按键)是按下状态。如果将掩码值 <code>4</code> 
					和位字段的值(也就是 {{MouseEvent/buttons}} 属性值)进行与操作结果为 
					<code>true</code> (或者说是 <code>1</code> )，则表示(事件触发时)鼠标辅助按键 
					/ 中间按键是按下状态。
					</p>
	
					<p class="example">
					在JavaScript中，要初始化 {{MouseEvent/buttons}} 属性，
					例如想要设置右键(2)和中键(4)同时被按下的状态，可以将buttons的值分配为: <br/>
					<code>&nbsp;&nbsp;{ buttons: 2 | 4 }</code> </br/>
					或者: <br/>
					<code>&nbsp;&nbsp;{ buttons: 6 }</code>
					</p>
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>relatedTarget</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">relatedTarget</code></i>，
					<code>EventTarget</code> 
					<span class="replacement"> 类型， 
					默认值为 <code>null</code> </span>
				</dt>
				<dd>
					<code>relatedTarget</code> 应该初始化为鼠标指针刚刚离开其边界的元素
					(在发生 <em>mouseover</em> 或 <em>mouseenter</em> 事件的情况下)
					或鼠标指针正在进入其边界的元素(在发生 <em>mouseout</em> 或 <em>mouseleave</em> 
					或 <em>focusout</em> 事件的情况下)。对于其他事件，不需要分配此值(并设为默认值 
					<code>null</code> )。
				</dd>
	
			</dl>
	
	<p id="current-click-count">
	在生成鼠标事件时，实现 <span class="zh-upper">必须</span> 
	维护 <em>当前的点击次数</em> 。这 <span class="zh-upper">必须</span> 
	是一个非负整数，表示在特定时间内连续点击定位设备按键的次数。
	计数重置之后的延迟是取决于环境配置。

	<p class="note custom-note">
		这个点击次数使用 {{UIEvent}} 定义的 {{UIEvent/detail}} 属性保存。
	</p>

	</p>
	
	<h4 id="event-modifier-initializers">事件修饰符初始化器</h4>
	
		{{MouseEvent}} 和 {{KeyboardEvent}} 接口共享一组键盘修饰符属性，
		并支持检索附加修饰符状态的机制。以下字典使开发者能够初始化
		{{MouseEvent}} 和 {{KeyboardEvent}} 接口的键盘修饰符属性，
		以及通过 {{KeyboardEvent/getModifierState()}} 
		查询附加键盘修饰符状态。使用此字典构造事件的步骤在 
		<a href="#event-constructors">事件构造函数</a> 部分中进行了定义。
	
		<pre class="idl">
		dictionary EventModifierInit : UIEventInit {
			boolean ctrlKey = false;
			boolean shiftKey = false;
			boolean altKey = false;
			boolean metaKey = false;
	
			boolean modifierAltGraph = false;
			boolean modifierCapsLock = false;
			boolean modifierFn = false;
			boolean modifierFnLock = false;
			boolean modifierHyper = false;
			boolean modifierNumLock = false;
			boolean modifierScrollLock = false;
			boolean modifierSuper = false;
			boolean modifierSymbol = false;
			boolean modifierSymbolLock = false;
		};
		</pre>
	
		<dl dfn-for="EventModifierInit">
			<dt class="origin-dfn"><dfn dict-member>ctrlKey</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">ctrlKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				如果要将 KEYCAP{Control} 键修饰符视为活动状态，
				则将 {{MouseEvent}} 或 {{KeyboardEvent}} 
				对象的 <code>ctrlKey</code> 属性初始化为 
				<code>true</code>，否则为 <code>false</code> 。

				当为 <code>true</code> 时，实现还必须初始化事件对象的键修饰符状态，
				以便在提供参数 KEYCAP{Control} 时，对 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 的调用必须返回 <code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>shiftKey</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">shiftKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				如果要将 KEYCAP{Shift} 键修饰符视为活动状态，
				则将 {{MouseEvent}} 或 {{KeyboardEvent}} 
				对象的 <code>shiftKey</code> 属性初始化为 
				<code>true</code>，否则为 <code>false</code> 。

				当为 <code>true</code> 时，实现还必须初始化事件对象的键修饰符状态，
				以便在提供参数 KEYCAP{Shift} 时，对 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 的调用必须返回 <code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>altKey</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">altKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				如果要将 KEYCAP{Alt} (可替代)(或 KEYCAP{Option} )键修饰符视为活动状态，
				则将 {{MouseEvent}} 或 {{KeyboardEvent}} 
				对象的 <code>altKey</code> 属性初始化为 
				<code>true</code>，否则为 <code>false</code> 。

				当为 <code>true</code> 时，实现还必须初始化事件对象的键修饰符状态，
				以便在提供参数 KEYCAP{Alt} 时，对 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 的调用必须返回 <code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>metaKey</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">metaKey</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				如果要将 KEYCAP{Meta} 键修饰符视为活动状态，
				则将 {{MouseEvent}} 或 {{KeyboardEvent}} 
				对象的 <code>metaKey</code> 属性初始化为 
				<code>true</code>，否则为 <code>false</code> 。

				当为 <code>true</code> 时，实现还必须初始化事件对象的键修饰符状态，
				以便在提供参数 KEYCAP{Meta} 时，对 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 的调用必须返回 <code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierAltGraph</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierAltGraph</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{AltGraph} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>

			<dt class="origin-dfn"><dfn dict-member>modifierCapsLock</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierCapsLock</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{CapsLock} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>

			<dt class="origin-dfn"><dfn dict-member>modifierFn</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierFn</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{Fn} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierFnLock</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierFnLock</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{FnLock} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierHyper</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierHyper</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{Hyper} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierNumLock</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierNumLock</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{NumLock} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierScrollLock</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierNumLock</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{NumLock} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierSuper</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierSuper</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{Super} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierSymbol</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierSymbol</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{Symbol} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
	
			<dt class="origin-dfn"><dfn dict-member>modifierSymbolLock</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">modifierSymbolLock</code></i>，
					<code>boolean</code> 
					<span class="replacement"> 类型，
				默认值为 <code>false</code> </span>
				</dt>
			<dd>
				初始化事件对象的键修饰符状态，以便在提供 KEYCAP{SymbolLock} 
				参数时，调用 {{MouseEvent/getModifierState()}} 
				或 {{KeyboardEvent/getModifierState()}} 必须返回 
				</code>true</code> 。
			</dd>
		</dl>
		
		<p class="note custom-note">
			关于修饰符键的表示的具体键盘按键，
			在不同的键盘设备和不同的操作系统上，甚至不同的浏览器上，
			都会有不同的映射关系以及不同的修饰符键支持程度。
			可以参阅 [[UIEvents-Key]] 中的 [=修饰符键值表格=] 
			获取非标准有效的修饰符键列表。也可以参阅 
			<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#modifier_keys_on_gecko">
			MDN-KeyboardEvent-getModifierState-modifier_keys_on_gecko</a> 
			了解火狐浏览器内核支持的修饰符键。
		</p>
	
	<h4 id="events-mouseevent-event-order">鼠标事件顺序</h4>

		本规范中定义的某些鼠标事件 <span class="zh-upper">必须</span> 
		按相对于彼此的固定顺序发生。
		下面的内容显示了当定位设备的光标移动到元素上时 
		<span class="zh-upper">必须</span> 发生的事件序列: 
	
		++---+------------+---------+------------------------------------------+
		=| # | 事件类型   | 元素    | 注释                                     |
		 +---+------------+----o----+------------------------------------------+
		+| 1 | mousemove  |         |                                          |
		+|   |            |         | <em>定位设备(的光标)移入元素A...</em>    |
		+| 2 | mouseover  |    A    |                                          |
		+| 3 | mouseenter |    A    |                                          |
		+| 4 | mousemove  |    A    | 有多个 EVENT{mousemove} 事件(被派发)     |
		+|   |            |         | <em>定位设备(的光标)移出元素A...</em>    |
		+| 5 | mouseout   |    A    |                                          |
		+| 6 | mouseleave |    A    |                                          |
		++---+------------+----------------------------------------------------+

		当定位设备(的光标)移入元素 <em>A</em> ，然后移入嵌套元素 <em>B</em> 
		，然后再移出时， <span class="zh-upper">必须</span> 发生以下事件序列: 
	
		++----+------------+---------+-----------------------------------------+
		=|  # | 事件类型   | 元素    | 注释                                    |
		 +----+------------+----o----+-----------------------------------------+
		+|  1 | mousemove  |         |                                         |
		+|    |            |         | <em>定位设备(的光标)移入元素A...</em>   |
		+|  2 | mouseover  |    A    |                                         |
		+|  3 | mouseenter |    A    |                                         |
		+|  4 | mousemove  |    A    | 有多个 EVENT{mousemove} 事件(被派发)    |
		+|    |            |         | <em>定位设备(的光标)移入                |
		 |    |            |         | 嵌套的元素B...</em>                     |
		+|  5 | mouseout   |    A    |                                         |
		+|  6 | mouseover  |    B    |                                         |
		+|  7 | mouseenter |    B    |                                         |
		+|  8 | mousemove  |    B    | 有多个 EVENT{mousemove} 事件(被派发)    |
		+|    |            |         | <em>定位设备(的光标)从元素B             |
		 |    |            |         | 移入元素A...</em>                       |
		+|  9 | mouseout   |    B    |                                         |
		+| 10 | mouseleave |    B    |                                         |
		+| 11 | mouseover  |    A    |                                         |
		+| 12 | mousemove  |    A    | 有多个 EVENT{mousemove} 事件(被派发)    |
		+|    |            |         | <em>定位设备(的光标)移出元素A...</em>   |
		+| 13 | mouseout   |    A    |                                         |
		+| 14 | mouseleave |    A    |                                         |
		++----+------------+---------------------------------------------------+

		有时，使用 CSS 可以在视觉上重叠元素。
		在以下示例中，标记为 A 、 B 和 C 的三个元素在网页上都具有相同的尺寸和绝对位置。
		在DOM中，元素 C 是 B 的子元素，而元素 B 是 A 的子元素: 
	
		<figure id="figure-mouse-event-stacked-elements">
			<img 
				src='images/stacked-event-mouse-dispatch.svg'
				height="250"
				alt="三个堆叠元素的图形表示，所有元素都重叠在一起。底部元素标记为 A ，顶部元素标记为 C "
			/>
			<figcaption>
			三个堆叠元素的图形表示，所有元素都重叠在一起，定位设备在堆叠上移动。
			</figcaption>
		</figure>

		当定位设备从元素堆叠外部移入标记为 C 的元素，然后再次移出时，
		<span class="zh-upper">必须</span> 发生以下一系列事件: 
	
		++----+------------+---------+-----------------------------------------+
		=|  # | 事件类型   | 元素    | 注释                                    |
		 +----+------------+----o----+-----------------------------------------+
		+|  1 | mousemove  |         |                                         |
		+|    |            |         | <em>定位设备移动到元素 C 中，           |
		 |    |            |         | 即堆叠中最顶层的元素</em>               |
		+|  2 | mouseover  |    C    |                                         |
		+|  3 | mouseenter |    A    |                                         |
		+|  4 | mouseenter |    B    |                                         |
		+|  5 | mouseenter |    C    |                                         |
		+|  6 | mousemove  |    C    | 有多个 EVENT{mousemove} 事件(被派发)    |
		+|    |            |         | <em>定位设备(的光标)移出元素 C...</em>  |
		+|  7 | mouseout   |    C    |                                         |
		+|  8 | mouseleave |    C    |                                         |
		+|  9 | mouseleave |    B    |                                         |
		+| 10 | mouseleave |    A    |                                         |
		++----+------------+---------------------------------------------------+
	
		<p class="note">
		EVENT{mouseover}/EVENT{mouseout} 事件只触发一次，而 
		EVENT{mouseenter}/EVENT{mouseleave} 事件触发三次(每个元素一次)。
		</p>

		以下是在元素上按下和释放与定位设备相关联的按键
		(例如，鼠标按键或触控板)时的典型事件序列: 
	
		++----+------------+---------------------------------------------------+
		=|  # | 事件类型   | 注释                                              |
		 +----+------------+---------------------------------------------------+
		+|  1 | mousedown  |                                                   |
		+|  2 | mousemove  | <span class="zh-upper">可选</span> ，             |
		 |    |            | 可以有0到多个，限制在点击的同一个元素内移动       |
		+|  3 | mouseup    |                                                   |
		+|  4 | click      |                                                   |
		+|  5 | mousemove  | <span class="zh-upper">可选</span> ，             |
		 |    |            | 可以有0到多个，限制在点击的同一个元素内移动       |
		+|  6 | mousedown  |                                                   |
		+|  7 | mousemove  | <span class="zh-upper">可选</span> ，             |
		 |    |            | 可以有0到多个，限制在点击的同一个元素内移动       |
		+|  8 | mouseup    |                                                   |
		+|  9 | click      |                                                   |
		+| 10 | dblclick   |                                                   |
		++----+------------+---------------------------------------------------+
	
		<p class="note">
		允许在一对 EVENT{mousedown} 和 EVENT{mouseup} 事件触发后，仍然派发 
		EVENT{click} 或 EVENT{dblclick} 事件(在EVENT{mousedown} 和 EVENT{mouseup} 
		事件派发过程中)的延迟时间、程度、距离和 EVENT{mousemove} 
		事件的数量的具体限制或容忍度，将取决于实现、设备和平台。
		这种容忍度有助于身体残疾的用户(浏览操作网页)，比如，
		有些手不稳的用户与定位设备交互时的场景。
		</p>
		 (鼠标事件顺序的) 实现都会确定适当的 <a href="#hysteresis">滞后</a> 
		容限，但通常情况下，当关联的 EVENT{mousedown} 和 EVENT{mouseup} 
		事件的事件目标是相同的元素且没有 EVENT{mouseout} 或 EVENT{mouseleave} 
		事件居于中间发生时，应该触发 EVENT{click} 和 EVENT{dblclick} 事件，
		当关联的 EVENT{mousedown} 和 EVENT{mouseup} 事件目标不同时，
		应该在二者 (两个不同事件目标元素) 最近公共祖先上触发 EVENT{click} 
		和 EVENT{dblclick} 事件。
	
		<p class="example">
		如果 EVENT{mousedown} 事件的事件目标是 HTML 文档的 
		<a href="#body-element">body</a> 元素，而相应的 EVENT{mouseup} 
		事件的事件目标是 <a href="#root-element">根元素</a> ，那么 EVENT{click} 
		事件将在 <a href="#root-element">根元素</a> 上触发，因为它是最近的公共祖先节点。
		</p>

		如果在鼠标事件序列期间从 DOM 中删除了 <a href="#event-target">事件目标</a> 
		(例如，目标元素)，则该序列中的其余事件 
		<span class="zh-upper">不得</span> 在该元素上触发。
	
		<p class="example">
		如果在 EVENT{mousedown} 事件触发的(事件处理程序中)从 DOM 中删除了目标元素，
		则不会在该元素上派发 EVENT{mouseup} 、 EVENT{click} 或 EVENT{dblclick} 
		事件，也不会派发任何默认激活事件。但是，在移除初始目标元素之后， EVENT{mouseup} 
		事件仍将在暴露给鼠标的元素上被派发。类似地，如果在 EVENT{mouseup} 
		事件的派发过程中从 DOM 中删除了目标元素，也不会派发 EVENT{click} 和后续事件。
		</p>
	
	<h4 id="events-mouse-types">鼠标事件类型</h4>

		鼠标事件类型如下所示。在嵌套元素的情况下，鼠标事件类型的事件目标总是嵌套最深的元素。
		目标元素的祖先元素 <span class="zh-upper">可以</span> 
		利用冒泡机制来获得在其后代元素发生的鼠标事件的通知。
	
		<h5 id="event-type-auxclick"><dfn>auxclick</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>auxclick</code></strong>                                               |
			+| 接口             | {{PointerEvent}}                                                                     |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 多种                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        |                
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : 表示                                            |
			 |                  |     <a href="#current-click-count">当前点击次数</a>; 当用户开始此操作时，属性值      |
			 |                  |     <span class="zh-upper">必须</span> 为 <code>1</code> ; 并且每次单击都递增        |
			 |                  |     <code>1</code> 。</li>                                                           |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | <li> {{PointerEvent}} 指定的属性，详情查看 [[!pointerevents3]] 规范。</li>           |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当用户按下并释放非主要指针按键(次要按键和辅助按键)时，
			或者以模拟这种操作的方式激活指针时， EVENT{auxclick} 
			事件类型 <span class="zh-upper">必须</span> 被派发到指针指示的 
			<a href="#topmost-event-target">最顶层的事件目标</a> 上。
			鼠标按键的致动方法取决于指针设备和环境配置，例如，它 
			<span class="zh-upper">可以</span> 
			取决于屏幕位置或指针设备按键的按下和释放之间的延迟。

			EVENT{auxclick} 事件只应被非主要指针按键触发 (即，当 {{MouseEvent/button}} 不为 
			<code>0</code> ，且按钮值大于 <code>1</code> 时) 。主按键 (如标准鼠标上的左键) 
			<span class="zh-upper">不得</span> 触发 EVENT{auxclick} 事件。
			请参阅 EVENT{click} 以获取与主按键关联的相应事件。
	
			EVENT{auxclick} 事件触发之前 <span class="zh-upper">可以</span> 
			是同一元素上触发的 EVENT{mousedown} 和 EVENT{mouseup} 
			事件，而不考虑其他节点类型 (例如文本节点) 之间的更改。
			根据环境配置，如果在按下和释放指针设备按键之间发生一个或多个 
			EVENT{mouseover} 、 EVENT{mousemove} 和 EVENT{mouseout} 事件，
			则 <span class="zh-upper">可以</span> 会派发 EVENT{auxclick} 事件。

			EVENT{auxclick} 事件类型的 <a href="#default-action">默认行为</a> 
			根据事件的 <a href="#event-target">事件目标</a> 和 {{MouseEvent/button}} 
			或 {{MouseEvent/buttons}} 属性的值而有所不同。 EVENT{auxclick} 
			事件类型的典型默认操作如下: 
	
			*	如果 <a href="#event-target">事件目标</a> 
				具有相关的 <a href="#activation-behavior">激活行为</a> ，则 
				<a href="#default-action">默认操作</a> <span class="zh-upper">必须</span> 
				是执行该激活行为 (参见 [[#event-flow-activation]] ) 。
	
			<p class="example">
			接收和处理点击中间按键触发的 EVENT{auxclick} 事件。<br/>
<code class="pre custom-code">myLink.addEventListener("auxclick", function(e) {
  if (e.button === 1) {
    // 这将阻止默认行为，例如
    // 在链接上单击鼠标中键时打开一个新选项卡。
    e.preventDefault();
    // 做一些其他事情来处理中间按键的点击，
    // 比如以适合应用程序的方式打开新选项卡中的链接或非链接按钮。
    // 还有其他操作，如应该在点击操作中完成——关闭标签条中的标签，
    // 也可以在这里完成。
  }
});
</code>
			</p>

			<p class="note">
			在单击右键的情况下， EVENT{auxclick} 事件是在任何 EVENT{contextmenu} 
			事件之后派发的。请注意，一些用户代理在显示上下文菜单时会吞下所有输入事件，
			因此 EVENT{auxclick} 可能不适用于此类场景中的应用程序。
			请参阅 <a href="#example-auxclick-right">此示例</a> 以获得更多说明。
			</p>
	
			<p id="example-auxclick-right" class="example">
			接收和处理点击右键触发的 EVENT{auxclick} 事件<br/>
<code class="pre custom-code">myDiv.addEventListener("contextmenu", function(e) {
	// 此调用确保不会显示任何上下文菜单来干扰页面接收事件。
  e.preventDefault();
});
myDiv.addEventListener("auxclick", function(e) {
  if (e.button === 2) {
    // 做一些其他事情来处理右键点击，
    // 比如在应用程序中打开自定义的上下文菜单。
  }
});
</code>
			</p>

		<h5 id="event-type-click"><dfn>click</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>click</code></strong>                                                  |
			+| 接口             | {{PointerEvent}}                                                                     |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | Varies                                                                               |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : indicates the                                   |
			 |                  |     <a href="#current-click-count">current click count</a>; the attribute value MUST |
			 |                  |     be <code>1</code> when the user begins this action and increments by             |
			 |                  |     <code>1</code> for each click.</li>                                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | <li> {{PointerEvent}} 指定的属性，详情查看 [[!pointerevents3]] 规范。</li>           |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当用户按下并释放主要指针按键时，或者以模拟这种操作的方式激活指针时，
			EVENT{click} 事件类型必须被派发到指针指示的 
			<a href="#topmost-event-target">最顶层的事件目标</a> 上。
			鼠标按键的致动方法取决于指针设备和环境配置，例如，它 
			<span class="zh-upper">可以</span> 取决于屏幕位置或指针设备按键的按下和释放之间的延迟。

			EVENT{click} 应仅针对主要指针按键触发 (即，当 {{MouseEvent/button}} 
			为 <code>0</code> ， {{MouseEvent/buttons}} 为 <code>1</code> 时) 。
			辅助按钮 (如标准鼠标上的中键或右键) 不得触发 EVENT{click} 事件。
			请参阅 EVENT{auxclick} 以获取与非主要按键关联的相应事件。

			EVENT{click} 事件触发之前 <span class="zh-upper">可以</span> 
			是同一元素上触发的 EVENT{mousedown} 和 EVENT{mouseup} 
			事件，而不考虑其他节点类型 (例如文本节点) 之间的更改。
			根据环境配置，如果在按下和释放指针设备按键之间发生一个或多个 
			EVENT{mouseover} 、 EVENT{mousemove} 和 EVENT{mouseout} 事件，
			则 <span class="zh-upper">可以</span> 会派发 EVENT{click} 事件。
			EVENT{click} 事件之后 <span class="zh-upper">可以</span> 
			还会触发 EVENT{dblclick} 事件。
	
			<p class="example">
			如果用户在具有较大行高样式的 <code>&lt;p&gt;</code> 
			元素的子节点——文本节点上按下鼠标按键，稍微移动鼠标(不松开鼠标按键)，
			使其不再位于包含文本的区域的上方，但仍然位于该 <code>&lt;p&gt;</code> 
			元素的包含块内 (即，指针位于同一文本块的行之间，但不位于文本节点本身的上方) ，
			然后松开鼠标按键，因为用户一直处于同一元素的领域内，这可能仍然会触发 
			EVENT{click} 事件 (假设鼠标按键点击和释放的时间间隔落在 
			EVENT{click} 的正常时间上的 <a href="#hysteresis">滞后</a> 范围内) 。
			请注意，用户代理生成的鼠标事件不会在文本节点上派发。
			</p>

			除了与指针设备关联外， EVENT{click} 事件类型<span class="zh-upper">必须</span> 
			作为元素激活的一部分进行调度，如 [[#event-flow-activation]] 所述。
	
			<p class="note">
			为了最大限度地提高可访问性，鼓励开发者在定义自定义控件的激活行为时使用
			EVENT{click} 事件类型，而不是其他更特定于设备的定位设备事件类型，如
			EVENT{mousedown} 或 EVENT{mouseup} 。尽管 EVENT{click} 
			事件类型起源于指针设备(例如鼠标)，但随后的实现增强将其扩展到了该关联之外，
			并且可以将其视为用于元素激活的设备独立的事件类型。
			</p>

			EVENT{click} 事件类型的 <a href="#default-action">默认行为</a> 
			根据事件的 <a href="#event-target">事件目标</a> 和 {{MouseEvent/button}} 
			或 {{MouseEvent/buttons}} 属性的值而有所不同。 EVENT{click} 
			事件类型的典型默认操作如下: 
	
			*	如果 <a href="#event-target">事件目标</a> 具有相关的激活行为，则 
				<a href="#default-action">默认行为</a> <span class="zh-upper">必须</span> 
				是执行该激活行为 (参见 [[#event-flow-activation]] ) 。
	
			*	如果 <a href="#event-target">事件目标</a> 是可聚焦的，则 
				<a href="#default-action">默认行为</a> <span class="zh-upper">必须</span> 
				是给予该元素文档焦点。
	
		<h5 id="event-type-contextmenu"><dfn>contextmenu</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>contextmenu</code></strong>                                            |
			+| 接口             | {{PointerEvent}}                                                                     |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 如果支持，调用出上下文菜单。                                                         |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : 0</li>                                          |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			在调用出上下文菜单之前派发此事件。

			当鼠标右键触发 EVENT{contextmenu} 事件时， EVENT{contextmenu} 事件
			<span class='zh-upper'>必须<span> 必须在 EVENT{mousedown} 事件之后被派发。
	
			<p class="note">
			根据平台的不同， EVENT{contextmenu} 事件可以在 EVENT{mouseup} 
			事件之前或之后派发。
			</p>
	
		<h5 id="event-type-dblclick"><dfn>dblclick</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>dblclick</code></strong>                                               |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : indicates the                                   |
			 |                  |     <a href="#current-click-count">current click count</a></li>                      |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备的主要按键在一个元素上被点击两次时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发这个事件。双击的定义取决于环境配置，
			但有一点是确定的: EVENT{mousedown} 、 EVENT{mouseup} 和 EVENT{dblclick} 时间
			的事件目标 <span class="zh-upper">必须</span> 相同。如果同时触发点击和双击时间，
			则此事件类型( EVENT{dblclick} ) <span class="zh-upper">必须</span> 在事件类型 
			EVENT{click} 之后派发，并且在事件类型 EVENT{mouseup} 之后分派。

			与 EVENT{click} 事件一样， EVENT{dblclick} 事件应该仅针对主要指针按键触发。
			次要按键 <span class="zh-upper">必须</span> 触发 EVENT{dblclick} 事件。
	
			<p class="note">
			取消(调用 {{Event/preventDefault()}} 方法) EVENT{click} 事件不会影响触发 
			EVENT{dblclick} 事件。
			</p>

			与 EVENT{click} 事件类型一样， EVENT{dblclick} 事件类型的
			<a href="#default-action">默认行为</a> 根据事件的 
			<a href="#event-target">事件目标</a> 和 {{MouseEvent/button}} 或 
			{{MouseEvent/buttons}} 属性的值而变化。通常， EVENT{dblclick} 
			事件类型的典型 <a href="#default-action">默认行为</a> 
			与对应的 EVENT{click} 事件类型的行为相匹配。
		
		<figure id="dbclick-default-action">
    	<img
				src='images/dbclick-default-action.gif'
				height="57"
				alt="译者添加的 <strong>非标准</strong> 图示: 在一个具有文本内容的 
				&lt;p&gt; 元素中进行双击操作，双击后触发的 EVENT{dblclick} 
				事件的默认行为是选中了一个英文单词，随后再次单机，全选了 
				&lt;p&gt; 元素中的其它可选部分" 
			/>
    	<div class="custom-figcaption" data-content="译者添加的非标准图示: ">
				在一个具有文本内容的 
				&lt;p&gt; 元素中进行双击操作，双击后触发的 EVENT{dblclick} 
				事件的默认行为是选中了一个英文单词，随后再次单机，全选了 
				&lt;p&gt; 元素中的其它可选部分
			</div>
		</figure>
	
		<h5 id="event-type-mousedown"><dfn>mousedown</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mousedown</code></strong>                                              |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 多种: 开始一个 拖/放  (drag/drop) 操作; 开始一个文本选择 (text selection) 操作; 开始 |
			 |                  | 滚动/平移 交互 (如果支持，可结合鼠标中键)                                            |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : 表示                                            |
			 |                  |     <a href="#current-click-count">当前单击计数</a> 加一。例如，                    |
			 |                  |     如果在 EVENT{mousedown} 触发之前没有发生点击,                                    |
			 |                  |     {{UIEvent/detail}} 的值就是 <code>1</code> </li>                                 |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当在元素上按下定位设备按键时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 必须派发此事件。
	
			<p class="note">
			许多实现使用 EVENT{mousedown} 事件来开始各种上下文相关的 
			<a href="#default-action">默认行为</a> 。如果取消此事件，
			则可以阻止这些 <a href="#default-action">默认行为</a> 。
			其中一些默认行为可能包括: 开始一个图像或链接的 拖/放  (drag/drop) 操作，
			开始文本选择等。此外，一些实现提供了鼠标驱动的平移功能——当按下鼠标中键时，
			EVENT{mousedown} 被派发，该功能会被激活。
			</p>
	
		<h5 id="event-type-mouseenter"><dfn>mouseenter</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mouseenter</code></strong>                                             |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 否                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 否                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : <code>0</code></li>                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : 指示指针设备正在退出 (exiting)     |
			 |                  |     的<a href="#event-target">事件目标</a> (如果有) </li>                            |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备移动到元素或其派生元素的边界上时， 
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。当元素或其后代元素之一移动到主要定位设备下方时，
			<a href="#user-agent">用户代理</a> 也 <span class="zh-upper">必须</span> 
			派发此事件。此事件类型类似于 EVENT{mouseover} ，但不同之处在于它不冒泡，
			并且当指针设备从一个元素移动到它的一个后代元素的边界上时， 
			<span class="zh-upper">不得</span>  (在原所在元素上)派发它。
	
			<p class="note">
			此事件类型与CSS 
			<a href="http://www.w3.org/TR/CSS2/selector.html#dynamic-pseudo-classes"
			title="Selectors"><code>:hover</code>伪类 </a> [[CSS2]] 有相似之处。另请参阅 
			EVENT{mouseleave} 事件类型。
			</p>
	
		<h5 id="event-type-mouseleave"><dfn>mouseleave</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mouseleave</code></strong>                                             |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 否                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 否                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : <code>0</code></li>                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : 指示指针设备正在进入               |
			 |                  |     的 <a href="#event-target">事件目标</a>  (如果有) </li>                          |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备移出元素及其所有后代元素的边界时， <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。
			当元素或其后代之一移动到不再位于主定位设备下方时，<a href="#user-agent">用户代理</a> 
			也 <span class="zh-upper">必须</span> 派发此事件。
			此事件类型类似于 EVENT{mouseout} ，但不同之处在于它不冒泡，
			并且在定位备离开元素的边界及其所有后代元素的边界之前， <span class="zh-upper">不得</span> 
			(在原始元素上) 派发它。
	
			<p class="note">
			此事件类型与CSS 
			<a href="http://www.w3.org/TR/CSS2/selector.html#dynamic-pseudo-classes"
			title="Selectors"><code>:hover</code>伪类 </a> [[CSS2]] 有相似之处。另请参阅 
			EVENT{mouseenter} 事件类型。
			</p>
	
		<h5 id="event-type-mousemove"><dfn>mousemove</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mousemove</code></strong>                                              |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : <code>0</code></li>                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备在元素上移动时， <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。
			移动定位设备时移动事件的触发频率取决于具体的实现、设备和平台，
			但 <span class="zh-upper">应当</span> 
			为持续的指针设备移动触发多个连续的 EVENT{mousemove} 事件，
			而不是为每个鼠标移动的实例触发一个事件。鼓励实现确定触发的最佳频率，
			以平衡响应性和性能。
	
			<p class="note">
			在一些实现环境中，例如浏览器，如果用户开始了拖动操作
			 (例如，按下鼠标按键) 并且定位设备已经离开了用户代理的边界，
			则 EVENT{mousemove} 事件可以继续激发。
			</p>
	
			<p class="note" id="mousemove-now-cancelable">
			此事件以前在 DOM Level 2 Events 中被指定为不可取消，
			但已更改为可取消，以反映用户代理之间现有的互操作性。
			</p>
	
		<h5 id="event-type-mouseout"><dfn>mouseout</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mouseout</code></strong>                                               |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : <code>0</code></li>                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : 指示定位设备正在进入的             |
			 |                  |     <a href="#event-target">事件目标</a> (如果有的话) </li>                          |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备移出元素的边界时，或者当元素移动到不再位于主定位设备下方时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。此事件类型类似于 EVENT{mouseleave} ，但不同之处在于它可以冒泡，
			并且当指针设备从一个元素移动到它的一个派生元素的边界上时，
			<span class="zh-upper">必须</span> 派发它。
	
			<p class="note">
			另请参见 EVENT{mouseover} 事件类型。
			</p>
	
		<h5 id="event-type-mouseover"><dfn>mouseover</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mouseover</code></strong>                                              |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : <code>0</code></li>                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : 指示定位设备正在离开的             |
			 |                  |     <a href="#event-target">事件目标</a> (如果有的话) </li>                          |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备移出元素的边界时，或者当元素移动到不再位于主定位设备下方时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。此事件类型类似于 EVENT{mouseenter} ，但不同之处在于它可以冒泡，
			并且当指针设备移动到具有同一 <a href="#event-listener">事件监听器</a> 
			实例的事件目标的祖先元素的边界上时， <span class="zh-upper">必须</span> 派发它。
	
			<p class="note">
			另请参阅 EVENT{mouseout} 事件类型。
			</p>
	
		<h5 id="event-type-mouseup"><dfn>mouseup</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>mouseup</code></strong>                                                |
			+| 接口             | {{MouseEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : 表示                                            |
			 |                  |     <a href="#current-click-count">当前单击计数</a> 加一。</li>                      |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 基于指针在屏幕上的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 基于指针在屏幕上的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(水平)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 基于指针在视口中的(竖直)位置的值</li>    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 基于当前按下的(鼠标)按键表示的值</li>     |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 值基于当前按下的所有(鼠标)按键表示的值， |
			 |                  |     如果未按下任何按键，则为 <code>0</code> </li>                                    |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : <code>null</code></li>             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+

			当定位设备按键在元素上释放时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。
	
			<p class="note">
			在某些实现环境中，例如浏览器，即使定位设备离开了用户代理的边界，
			也可以派发 EVENT{mouseup} 事件，例如，
			用户按下鼠标按键开始拖动操作的场景。
			</p>

<h3 id="events-wheelevents">滚轮事件</h3>
	滚轮是可以在一个或多个空间维度上旋转的设备，并且它通常与指针设备关联。
	滚轮的坐标系取决于环境配置。
		* 用户的环境可以被配置为 <strong>沿y轴的垂直滚动</strong>、 
			<strong>沿x轴的水平滚动</strong> 以及
			<strong>沿z轴的缩放滚动</strong> 。
	
	<p class="example">
	用户的环境可能被配置为将垂直滚动与沿y轴的旋转相关联，
	将水平滚动与沿x轴的旋转相关联，
	并将缩放与沿z轴的旋转相关联。
	</p>
	
	{{WheelEvent}} 对象的 <code>deltaX</code> 、<code>deltaY</code> 和
	<code>deltaZ</code> 属性表示沿其各自轴的测量值，单位为像素、行或页。
	(这些属性)报告的测量值是通过特定于环境的算法将滚轮装置的实际 旋转
	/ 移动 转换为适当的值和单位后提供的。
	
	<p class="note">
	用户的环境设置可以自定义，从而以不同的方式解释滚轮设备的实际 旋转 / 移动。
	普通 <q>有齿轮的</q> (dented) 鼠标滚轮的一次移动可以产生 162 像素的测量值
	( 162 只是一个示例值，实际值可能取决于用户代理的当前屏幕尺寸)。
	但用户可以更改默认环境设置以加快鼠标滚轮的速度，从而增加这个数字。
	此外，一些鼠标滚轮软件可以支持加速(滚轮旋转/移动得越快，每次测量的 
	<a href="#delta">增量</a> 越大)，甚至可以支持亚像素(sub-pixel)
	<a href="#rotation">旋转</a> 测量值。
	因此，开发者不能假定在一个用户代理中的给定一个<a href="#rotation">旋转</a> 
	测量值会在所有用户代理中产生相同的 <a href="#delta">增量</a> 值。
	</p>
	
	deltaX 、 deltaY 和 deltaZ 属性的值的符号(正或负)，在实际滚轮装置沿同一方向 
	旋转 / 移动 时，<span class="zh-upper">必须</span> 在多次派发的 
	EVENT{wheel} 事件中保持一致。如果一个用户代理将滚动作为 
	EVENT{wheel} 事件的默认行为，那么 <a href="#delta">delta</a> 
	的符号应该由右手坐标系给出，其中正 X 、 Y 和 Z 轴分别指向文档的最右边、
	最底边和最远深度(远离用户)。
	
	<p class="note">
	单个用户代理可以(取决于其环境和硬件配置)以不同的方式解释滚轮上的相同物理用户交互。
	例如，从上到下在触控板边缘上的垂直滑动可以被解释为轮子动作，
	其目的是向下滚动页面或向上移动页面(即，分别产生正或负的 deltaY 值)。
	</p>
	
	<h4 id="interface-wheelevent">WheelEvent 接口</h4>
	
		<p class="intro-dom">在本规范中引入介绍</p>

		{{WheelEvent}} 接口提供与 EVENT{wheel} 事件相关联的特定上下文信息。
	
		要创建 {{WheelEvent}} 接口的实例，请使用 {{WheelEvent}} 构造函数，
		并传递可选的 {{WheelEventInit}} 字典。
	
		<h5 id="idl-wheelevent">WheelEvent</h5>
	
			<pre class="idl">
			[Exposed=Window]
			interface WheelEvent : MouseEvent {
				constructor(DOMString type, optional WheelEventInit eventInitDict = {});
				// DeltaModeCode
				const unsigned long DOM_DELTA_PIXEL = 0x00;
				const unsigned long DOM_DELTA_LINE	= 0x01;
				const unsigned long DOM_DELTA_PAGE	= 0x02;
	
				readonly attribute double deltaX;
				readonly attribute double deltaY;
				readonly attribute double deltaZ;
				readonly attribute unsigned long deltaMode;
			};
			</pre>
	
			<dl dfn-for="WheelEvent">
				<dt><dfn const>DOM_DELTA_PIXEL</dfn></dt>
				<dd>
					<a href="#delta">delta</a> 的测量单位 
					<span class="zh-upper">必须</span> 必须是像素。
					这是大多数操作系统和实现配置中最典型的情况。
				</dd>
	
				<dt><dfn const>DOM_DELTA_LINE</dfn></dt>
				<dd>
					<a href="#delta">delta</a> 的测量单位
					<span class="zh-upper">必须</span> 是单独的文本行。
					许多表单控件都是这种情况。
				</dd>
	
				<dt><dfn const>DOM_DELTA_PAGE</dfn></dt>
				<dd>
					<a href="#delta">delta</a> 的测量单位 
					<span class="zh-upper">必须</span> 是页面，
					(一个单位值)可以定义为单个屏幕，也可以定义为标定页面(demarcated page)。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>deltaX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaX</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，只读</span>
				</dt>
				
				<dd>
					在 EVENT{wheel} 事件的默认行为是滚动(scroll)的用户代理中，
					该值 <span class="zh-upper">必须</span> 是在事件未取消的情况下，
					沿 x 轴滚动的测量值(以像素、行或页面为单位)。否则(默认行为并非滚动)，
					这是滚轮设备围绕 x 轴的运动时，实现决定的测量值(以像素、行或页为单位)。
					
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>0.0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>deltaY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaY</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，只读</span>
				</dt>
				<dd>
					在 EVENT{wheel} 事件的默认行为是滚动(scroll)的用户代理中，
					该值 <span class="zh-upper">必须</span> 是在事件未取消的情况下，
					沿 y 轴滚动的测量值(以像素、行或页面为单位)。否则(默认行为并非滚动)，
					这是滚轮设备围绕 y 轴的运动时，实现决定的测量值(以像素、行或页为单位)
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>0.0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>deltaZ</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaZ</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，只读</span>
				</dt>
				<dd>
					在 EVENT{wheel} 事件的默认行为是滚动(scroll)的用户代理中，
					该值 <span class="zh-upper">必须</span> 是在事件未取消的情况下，
					沿 z 轴滚动的测量值(以像素、行或页面为单位)。否则(默认行为并非滚动)，
					这是滚轮设备围绕 z 轴的运动时，实现决定的测量值(以像素、行或页为单位)
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>0.0</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>deltaMode</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaMode</code></i>，
					<code>unsigned long</code>
					<span class="replacement"> 类型(32位无符号整型)，默认值为
						<code>0</code>
					</span>
				</dt>
				<dd>
					<code>deltaMode</code> 属性包含对 <a>delta</a> 值的测量单位的指示。
					默认值为 {{WheelEvent/DOM_DELTA_PIXEL}} (像素)。
	
					此属性 <span class="zh-upper">必须</span> 设置为 DOM_DELTA 常量之一，
					以指示 <a>delta</a> 值的测量单位。
					合适(precise)的测量单位是由设备、操作系统和应用程序配置共同决定的。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>0</code> 。
				</dd>
			</dl>
	
		<h5 id="idl-wheeleventinit">WheelEventInit</h5>
	
			<pre class="idl">
			dictionary WheelEventInit : MouseEventInit {
				double deltaX = 0.0;
				double deltaY = 0.0;
				double deltaZ = 0.0;
				unsigned long deltaMode = 0;
			};
			</pre>
	
			<dl dfn-for="WheelEventInit">
				<dt class="origin-dfn"><dfn dict-member>deltaX</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaX</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，默认值为 
					<code>0.0</code> </span>
				</dt>
				
				<dd>查阅下面的 <code>deltaZ</code> 属性。</dd>
	
				<dt class="origin-dfn"><dfn dict-member>deltaY</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaY</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，默认值为
					<code>0.0</code> </span>
				</dt>
				<dd>查阅下么 <code>deltaZ</code> 属性。</dd>
	
				<dt class="origin-dfn"><dfn dict-member>deltaZ</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaZ</code></i>，
					<code>double</code>
					<span class="replacement"> 类型(64位双精度浮点数)，默认值为 
					<code>0.0</code> </span>
				</dt>
				<dd>
					初始化 {{WheelEvent}} 对象的 {{WheelEvent/deltaZ}} 属性。
					该属性(以及deltaX和deltaY属性)
					的相对正值由右手坐标系给出，其中 X 、 Y 和 Z 
					轴分别指向文档的最右边、最下边和最远深度(远离用户)，
					相对负值在各自相反的方向上。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>deltaMode</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">deltaMode</code></i>，
					<code>unsigned long</code>
					<span class="replacement"> 类型(32位无符号整型)，默认值为
						<code>0</code>
					</span>
				</dt>
				
				<dd>
					可以将 {{WheelEvent}} 对象上的 {{WheelEvent/deltaMode}} 
					属性初始化为枚举值 0 、 1 或 2 ，如果滚轮 <a href="#rotation">旋转</a> 
					会导致滚动，这些值分别表示滚动的像素量
					( {{WheelEvent/DOM_DELTA_PIXEL}} )、滚动的行数
					( {{WheelEvent/DOM_DELTA_LINE}} )或滚动的页数 
					( {{WheelEvent/DOM_DELTA_PAGE}} )。
				</dd>
			</dl>

			<p 
				class="custom-example" 
				data-content="非规范例子: 关于 delta 值正负以及右手坐标系">
				<q>初始化 {{WheelEvent}} 对象的 {{WheelEvent/deltaZ}} 属性。
					该属性(以及deltaX和deltaY属性)的相对正值由右手坐标系给出</q>，
					意思就是 daltaX/Y/Z 属性的值的正负符号确定和文档位置坐标系相同。
					对于鼠标设备而言， <strong>逆时针</strong> 
					滚动鼠标滚轮(向下，向右或向远离用户)时， <a>delta</a> 值为正，
					<strong>顺时针</strong> 滚动鼠标滚轮(向上，向左或靠近用户)时，
					<a>delta</a> 值为负。
			</p>
	
	<h4 id="events-wheel-types">Wheel Event Types</h4>
	
		<h5 id="event-type-wheel"><dfn>wheel</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>wheel</code></strong>                                                  |
			+| 接口             | {{WheelEvent}}                                                                       |
			+| 同步 / 异步      | 异步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | <a href="#cancelability-of-wheel-events">多种情况</a>                                |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 滚动(或缩放)文档                                                                     |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : <a href="#topmost-event-target">                    |
			 |                  |     最顶层的事件目标</a></li>                                                        | 
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenX}} : 如果滚轮与定位设备相关联，               |
			 |                  |     则是基于屏幕上指针(水平)位置的值，                                               |
			 |                  |     否则为 <code>0</code></li>                                                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/screenY}} : 如果滚轮与定位设备相关联，               |
			 |                  |     则是基于屏幕上指针(竖直)位置的值，                                               |
			 |                  |     否则为 <code>0</code></li>                                                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientX}} : 如果滚轮与定位设备相关联，               |
			 |                  |     则是基于视口上指针(水平)位置的值，                                               |
			 |                  |     否则为 <code>0</code></li>                                                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/clientY}} : 如果滚轮与定位设备相关联，               |
			 |                  |     则是基于视口上指针(竖直)位置的值，                                               |
			 |                  |     否则为 <code>0</code></li>                                                       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/altKey}} : 如果 KEYCAP{Alt} 修饰符处于活动状态，则为 |
			 |                  |     <code>true</code> ，否则为 <code>false</code> </li>                              |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} : 如果 KEYCAP{Ctrl} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/shiftKey}} : 如果 KEYCAP{Shift} 修饰符处于活动状态， |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/metaKey}} : 如果 KEYCAP{Meta} 修饰符处于活动状态，   |
			 |                  |     则为 <code>true</code> ，否则为 <code>false</code> </li>                         |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/button}} : 如果滚轮与定位设备相关联，                |
			 |                  |    	则值基于当前设备按下的按键, 否则为 <code>0</code></li>                           |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/buttons}} : 如果滚轮与定位设备相关联，               |
			 |                  |    	则值基于当前设备按下的所有按键, 如果没有按键按下，则为 <code>0</code></li>       |
			 |                  | <li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} : 指示定位设备所指向的               |
			 |                  |     <a href="#event-target">事件目标</a> (如果有)</li>                               |
			 |                  | <li>{{WheelEvent}}.{{WheelEvent/deltaX}} : 页面根据 deltaMode 表示的单位沿           |
			 |                  |     x 轴滚动的预期量; 或滚轮绕 x 轴运动的实现决定的值</li>                           |
			 |                  | <li>{{WheelEvent}}.{{WheelEvent/deltaY}} : 页面根据 deltaMode 表示的单位沿           |
			 |                  |     y 轴滚动的预期量; 或滚轮绕 y 轴运动的实现决定的值</li>                           |
			 |                  | <li>{{WheelEvent}}.{{WheelEvent/deltaZ}} : 页面根据 deltaMode 表示的单位沿           |
			 |                  |     z 轴滚动的预期量; 或滚轮绕 z 轴运动的实现决定的值</li>                           |
			 |                  | <li>{{WheelEvent}}.{{WheelEvent/deltaMode}} :                                        |
			 |                  |     deltaX 、 deltaY 和 deltaZ 属性的单位指示符(像素、行或页)</li>                   |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当鼠标滚轮沿着任何轴旋转/滚动时，或当等效输入设备
			(如鼠标球、某些平板电脑或触摸板等)模拟了此类动作时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 派发
			EVENT{wheel} 事件。根据平台和输入设备，对于旋钮的 <a>deltas</a> 
			(diagonal wheel deltas)，(它的事件)交付方式 既 
			<span class="zh-upper">可以</span> 是多个非零轴的 <a>delta</a> 整合入单个 
			EVENT{wheel} ，又 <span class="zh-upper">可以</span> 是为每个非零轴的 
			<a>delta</a> 触发单独的 EVENT{wheel} 事件。

			<p class="note custom-note">
			非零轴向包括 X 轴、 Y 轴和 Z 轴。在 <a>delta</a> 不为 <code>0</code> 时，
			<a>delta</a> 可以是 X ， Y， Z 三个轴上的增量值，
			上述介绍了两种处理旋钮操作产生多个轴方向不同的 
			<a>deltas</a> 值时的交付方式——既可以整合到一个 EVENT{wheel} ，
			使用三个轴对应的 {{WheelEvent/deltaX}} ， {{WheelEvent/deltaY}} ， 
			{{WheelEvent/deltaZ}} 属性指示各种轴增量值; 
			又可以为三个轴上的增量值派发三个 EVENT{wheel} 事件，只使用各自的 
			<a>delta</a> 指示对应的属性值。
			</p>
	
			EVENT{wheel} 事件类型的典型 <a href="#default-action">默认行为</a> 
			是按(用户代理)指定的数量滚动(或在某些情况下缩放)文档。如果此事件被取消，
			则实现 <span class="zh-upper">不得</span> 滚动或缩放文档
			(或执行与此事件类型相关的任何其他实现决定的的默认行为)。
	
			<p class="note">
			在一些 <a href="#user-agent">用户代理</a> 中，或者在一些输入设备中，
			滚轮转动的速度会影响 <a>delta</a> 值，更快的速度会产生更高(/大)的 
			<a>delta</a> 值。
			</p>
	
		<h5 id="cancelability-of-wheel-events">滚轮事件的可取消性</h5>
			<p>
			在一个滚轮事件上调用 <code>preventDefault</code> 可以阻止或中断滚动。
			为了获得最大的滚动性能，
			用户代理可能不会等待每个与滚动相关联的滚轮事件被处理完毕
			(检阅滚轮事件是否被取消)才派发事件。在这种情况下，用户代理应该生成 
			<code>cancelable</code> 属性为 <code>false</code> 的 <code>wheel</code> 事件，
			表明 <code>preventDefault</code> 不能用于阻止或中断滚动。否则 
			<code>cancelable</code> 属性将为 <code>true</code> 。
			</p>
	
			<p>
			特别是，当用户代理发现事件
			<a href="https://dom.spec.whatwg.org/#observing-event-listeners">
			没有非被动监听器(non-passive listeners)</a> 时，它应该只生成不可取消(uncancelable)的 
			<code>wheel</code> 事件。
			</p>

			<p class="note custom-note">
			在 [[DOM]] 中的 {{EventTarget}} 接口中介绍了 
			{{EventTarget/addEventListener()}} 方法的第三个参数，
			它的字典定义有一个 <code>passive</code> 属性，表示 
			<a href="#event-listener">事件监听器</a> 是否永远不会调用 
			{{Event/preventDefault()}} ，非被动监听器(non-passive listeners)就是 
			<code>passive</code> 设置为 <code>false</code> (默认值)的 
			<a href="#event-listener">事件监听器</a> ，它表示事件可被取消; 
			再理解上面的话，特意设置 <code>passive</code> 属性为
			<code>true</code> ，那么实现只会生成不可取消的 <code>wheel</code> 事件。
			总结一下就是: </br>
			① <code>wheel</code> 的默认监听器就是非被动监听器( <code>passive</code> 
			默认为 <code>false</code>)，所以一般的用户代理默认情况下允许在 
			<code>wheel</code> 的事件处理程序中调用 <code>preventDefault()</code> ，
			并且可以生效，生成的事件对象的 {{Event/cancelable}} 属性值为 
			<code>true</code>;</br>
			② 如果在使用 {{EventTarget/addEventListener()}} 给元素节点添加 
			<code>wheel</code> 的事件处理程序时，特意传入第三个参数且设置其
			<code>passive</code> 属性为 <code>true</code>，
			那么这个事件的监听器就是被动监听器(passive listener)，符合上述的
			<q><a href="https://dom.spec.whatwg.org/#observing-event-listeners">
			没有非被动监听器(non-passive listeners)</a> 时</q> 的情况。
			此时用户代理不允许在 <code>wheel</code> 的事件处理程序中调用 
			<code>preventDefault()</code>，如果调用也不会生效，生成的事件对象的 
			{{Event/cancelable}} 属性值为 <code>false</code>;
			</p>

			<p class="note custom-note" data-content="非规范注释: 关于scroll事件">
				<code>scroll</code> 事件类型的事件对象在 DOM2 中原本属于 
				[[#events-uievent-types]] 中定义的事件，为了保持事件类型定义的一致性，
				它被移出了 [[#events-uievent-types]] 规范的事件类型中，
				而是在 [[CSSOM-View]] 的 
				<a href="https://www.w3.org/TR/cssom-view-1/#scrolling-events">
				scrolling-events</a> 进行了明确说明，现在属于 {{Event}} 接口定义的事件。
				<code>scroll</code> 事件在以前的混杂模式下，通常是监听 <a>window</a> 
				对象以发现页面中相应元素变化，但是目前在标准模式下，对 
				<a href="#document">document</a> 对象以及元素添加 <code>scroll</code> 
				事件类型的事件监听器是正确的做法，可以通过这些被监听元素的 
				<code>scrollLeft</code> 和 <code>scrollTop</code> 
				属性获取垂直与水平滚动的距离。需要注意，<code>scroll</code> 
				事件是不冒泡，不可取消，同步触发的事件类型，而 EVENT{wheel} 是冒泡的，
				取消可控制的，异步触发的事件类型。
			</p>


<h3 id="events-inputevents">输入事件</h3>
	每当 DOM 作为用户操作的直接结果而被更新(或即将被更新)时，
	输入事件都会作为通知被派发(例如，可编辑区域的中的键盘输入，
	删除或设置文本格式...)。
	
	<h4 id="interface-inputevent">InputEvent 接口</h4>
	
		<h5 id="idl-inputevent">InputEvent</h5>
	
			<p class="intro-dom">在DOM Level 3中引入介绍</p>
	
			<pre class="idl">
			[Exposed=Window]
			interface InputEvent : UIEvent {
				constructor(DOMString type, optional InputEventInit eventInitDict = {});
				readonly attribute DOMString? data;
				readonly attribute boolean isComposing;
				readonly attribute DOMString inputType;
			};
			</pre>
	
			<dl dfn-for="InputEvent">

				<dt	class="origin-dfn"><dfn attribute>data</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">data</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，只读，可空</span>
				</dt>
				
				<dd>
					<code>data</code> 保存由一种输入方法生成的字符的值。
					这 <span class="zh-upper">可以</span> 是一个简单的 Unicode 
					字符或一个非空的 Unicode 字符序列 [[Unicode]] 。字符  
					<span class="zh-upper">应当</span> 按照 Unicode 
					规范化形式 <em>NFC</em> 的定义进行规范化，它在 [[UAX15]] 中定义。
					这个属性 <span class="zh-upper">可以</span> 包含 
					<a href="#empty-string">空字符串</a> 。

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 为 <code>null</code> 。
				</dd>

				<dt	class="origin-dfn"><dfn attribute>isComposing</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">isComposing</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					如果输入事件作为一个组合会话(composition session)的一部分发生，
					该属性值为 <code>true</code> ，也就是说，在一个 
					EVENT{compositionstart} 事件之后，在对应的 EVENT{compositionend} 
					事件之前触发。
					
					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是 <code>false</code> 。
				</dd>

				<dt	class="origin-dfn"><dfn attribute>inputType</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">inputType</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					<code>inputType</code>包含一个字符串，用于标识与事件关联的输入类型。
	
					有关此属性的有效值列表，参考 [[Input-Events]] 规范

					该属性的 <a href="#un-initialized-value">未初始化值</a> 
					<span class="zh-upper">必须</span> 是空字符串 <code>""</code> 。
				</dd>
			</dl>
	
		<h5 id="idl-inputeventinit">InputEventInit</h5>
	
			<pre class="idl">
			dictionary InputEventInit : UIEventInit {
				DOMString? data = null;
				boolean isComposing = false;
				DOMString inputType = "";
			};
			</pre>
	
			<dl dfn-for="InputEventInit">
				<dt class="origin-dfn"><dfn dict-member>data</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">data</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，可空，默认值为 
					<code>null</code></span>
				</dt>
				
				<dd>
					初始化 InputEvent 对象的 <code>data</code> 属性。
				</dd>

				<dt class="origin-dfn"><dfn dict-member>isComposing</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">isComposing</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，默认值为 <code>false</code></span>
				</dt>
				<dd>
					初始化 InputEvent 对象的 <code>isComposing</code> 属性。
				</dd>

				<dt class="origin-dfn"><dfn dict-member>inputType</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">inputType</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，默认值为 <code>""</code></span>
				</dt>
				<dd>
					初始化 InputEvent 对象的 <code>inputType</code> 属性。
				</dd>
			</dl>
	
	<h4 id="events-inputevent-event-order">输入事件顺序</h4>
	
		本规范中定义的输入事件 <span class="zh-upper">必须</span> 
		按相对于彼此的固定顺序发生。
	
		++---+--------------------+---------------------------------------------------+
		=| # | 事件类型           | 注释                                              |
		 +---+--------------------+---------------------------------------------------+
		+| 1 | EVENT{beforeinput} |                                                   |
		+|   |                    | <em>DOM 元素被更新</em>                           |
		+| 2 | EVENT{input}       |                                                   |
		++---+--------------------+---------------------------------------------------+
	
	<h4 id="events-input-types">输入事件类型</h4>
	
		<h5 id="event-type-beforeinput"><dfn>beforeinput</dfn></h5>
			
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>beforeinput</code></strong>                                            |
			+| 接口             | {{InputEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡   	        | 是                                                                                   |
			+| 可信目标对象     | <code>Element</code> (特别的，应该是能被控制的元素类型，例如                         |
			 |                  | <code>HTMLInputElement</code> , 等) 或者是其他设置了                 					       |
			 |                  | <code>contenteditable</code> 属性的 <code>Element</code>                             |
			+| 可取消默认行为   | 是                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 更新DOM元素                                                                          |
			+| 上下文<br/>      | <ul>                                                                                 |
		   | (可信事件) 	    | <li>{{Event}}.{{Event/target}} : 将被更新的<a href="#event-target">事件目标对象      |
			 |                  | </a></li>                                                                            |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{InputEvent}}.{{InputEvent/data}} : 包含将添加到元素中的的字符串数据，          |
			 |                  |     如果内容将被删除，则该字符串                                                     |
			 |                  |     <span class="zh-upper">可以</span> 为<code>null</code></li>                      |
			 |                  | <li>{{InputEvent}}.{{InputEvent/isComposing}} : 如果此事件是在                       |
			 |                  |  		<a href="#keys-dead">死键</a> 序列(dead key sequence)期间，或在                  |
			 | 									|  		<a href="#input-method-editor">输入法编辑器</a>                                  |
			 |                  |     处于活动状态时                                                                   |
			 |                  |     派发的(以便派发 <a href="#events-compositionevents">合成事件</a> )，             |
			 |                  |     则为<code>true</code>; 否则为 <code>false</code> 。</li>                         |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当 DOM 即将更新时， <a href="#user-agent">用户代理</a> 必须派发此事件。
	
		<h5 id="event-type-input"><dfn>input</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>input</code></strong>                                                  |
			+| 接口             | {{InputEvent}}                                                                       |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 是                                                                                   |
			+| 可信目标对象     | <code>Element</code> (特别的，应该是能被控制的元素类型，例如                         |
			 |                  | <code>HTMLInputElement</code>, 等) 或者是其他设置了                                  |
			 |                  | <code>contenteditable</code> 属性的<code>Element</code>                              |
			+| 可取消默认行为   | 是                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 刚刚被更新的<a href="#event-target">                |
			 |                  | 事件目标对象</a></li>                                                                |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{InputEvent}}.{{InputEvent/data}} : 包含将添加到元素中的的字符串数据，          |
			 |                  | 如果内容将被删除，则该字符串可                                                       |
			 |                  | 能为<a href="#empty-string">空字符串</a></li>                                        |
			 |                  | <li>{{InputEvent}}.{{InputEvent/isComposing}} : 如果此事件是在                       |
			 |                  | <a href="#keys-dead">死键</a> 序列(dead key sequence) 期间                           |
			 |                  | 或在<a href="#input-method-editor">输入法编辑器</a>处于活动状态时派发的              |
			 |                  |(以便派发<a href="#events-compositionevents">合成事件</a>)，                          |
			 |                  | 则为 <code>true</code> ; 否则为 <code>false</code> 。                                |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当DOM被更新后，<a href="#user-agent">用户代理</a>必须立即派发此事件

<h3 id="events-keyboardevents">键盘事件</h3>
	键盘事件是依赖设备的，也就是说，
	键盘事件依赖于输入设备的能力以及输入设备在操作系统中的映射方式。
	这种映射方式可以参阅 <a href="#keys">键盘事件和键值</a> ，
	其中包括键盘事件如何与合成事件结合使用的例子。键盘事件是否会生成，
	取决于具体的字符生成设备(character generation device)。
	
	<p class="note">
	键盘事件只是提供一种文本输入的形式(modality)，对于编辑场景，也可以考虑使用 
	{{InputEvent}} 作为键盘事件的替代(或补充)。
	</p>
	
	<h4 id="interface-keyboardevent">KeyboardEvent 接口</h4>
	
		<p class="intro-dom">在本规范中引入介绍: </p>
	
		{{KeyboardEvent}} 接口提供具体的和键盘设备相关的上下文信息。
		每个键盘事件都是由一个值引用一个按键。键盘事件通常指向具有焦点的元素。
		
		{{KeyboardEvent}} 接口为常见的修饰符按键——{{KeyboardEvent/ctrlKey}},
		{{KeyboardEvent/shiftKey}}, {{KeyboardEvent/altKey}},
		{{KeyboardEvent/metaKey}}提供方便使用的属性。这些属性的值可以等价使用
		{{KeyboardEvent/getModifierState()}} 方法通过传递对应{{KeyboardEvent/getModifierState()}} with KEYCAP{Control},
		KEYCAP{Shift}, KEYCAP{Alt}, 或 KEYCAP{Meta}等按键修饰符获取。
	
		为了创建一个{{KeyboardEvent}}接口的实例，可以使用{{KeyboardEvent}}的构造函数，并传递一个可选的{{KeyboardEventInit}}字典。
	
		<h5 id="idl-keyboardevent">KeyboardEvent</h5>
	
			<pre class="idl" data-highlight="webidl">
			[Exposed=Window]
			interface KeyboardEvent : UIEvent {
				constructor(DOMString type, optional KeyboardEventInit eventInitDict = {});
				// KeyLocationCode(按键位置码)
				const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
				const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
				const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
				const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;
	
				readonly attribute DOMString key;
				readonly attribute DOMString code;
				readonly attribute unsigned long location;
	
				readonly attribute boolean ctrlKey;
				readonly attribute boolean shiftKey;
				readonly attribute boolean altKey;
				readonly attribute boolean metaKey;
	
				readonly attribute boolean repeat;
				readonly attribute boolean isComposing;
	
				boolean getModifierState(DOMString keyArg);
			};
			</pre>
	
			<dl dfn-for="KeyboardEvent">
				<dt><dfn const>DOM_KEY_LOCATION_STANDARD</dfn></dt>
				<dd>
					激活按键(key activation) <span class="zh-upper">不得</span>  
					区分为按键的左侧或右侧版本，并且( KEYCAP{NumLock} 键除外)
					激活按键不能源自数字键盘(或不能源自与数字键盘对应的虚拟按键)。
	
					<p class="example">
					一个 PC 101 美国标准键盘上的 KEYCAP{Q} 键。<br/>
					一个 PC 101 美国标准键盘上的 KEYCAP{NumLock} 键。<br/>
					一个 PC 101 美国标准键盘上，位于键盘主要区域的 KEYCAP{1} 键。<br/>
					</p>

					<div class="note custom-note">
					标准按键位置: 这个位置下的按键不存在左右两个按键
					(一般有左右两个的键都有属于修饰键)，且不包括小键盘区域的按键，详情见
					[[UIEvents-Code]] 的 [=修饰符按键=] 和 [=小键盘=] 。
					</div>
					
				</dd>
	
				<dt><dfn const>DOM_KEY_LOCATION_LEFT</dfn></dt>
				<dd>
					激活按键源自左侧按键位置(当该按键可能有多个位置时)。
	
					<p class="example">
					PC 101 美国键盘上左侧的 KEYCAP{Control} 键。
					</p>
				</dd>
	
				<dt><dfn const>DOM_KEY_LOCATION_RIGHT</dfn></dt>
				<dd>
					激活按键源自右侧按键位置(当该按键可能有多个位置时)。
	
					<p class="example">
					PC 101 美国键盘上右侧的 KEYCAP{Shift} 键。
					</p>
				</dd>
	
				<dt><dfn const>DOM_KEY_LOCATION_NUMPAD</dfn></dt>
				<dd>
					激活按键源于数字 [=小键盘=] 或与数字 [=小键盘=] 对应的虚拟按键
					(当该按键可能有多个位置时)。请注意， KEYCAP{NumLock} 键的 
					{{KeyboardEvent/location}} 属性应始终编码为 
					{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}} 。
	
					<p class="example">
					PC 101 美国键盘的数字板(就是小键盘)的 KEYCAP{1} 键。
					</p>
				</dd>

				<div class="note custom-note">
				按键位置码代表的四个位置分别称为: 标准按键位置，左侧按键位置，
				右侧按键位置，数字板按键位置，关于它们具体包含的按键如下图，
				该图例举出了 PC 101 美国键盘上的四个位置的按键所属，
				其它标准键盘请参阅 [[UIEvents-Code]] 的 [=键盘布局=] 。
				
				<figure id="keyboard-101-us-location">
    		<img src='images/keyboard-101-us-location.svg' 
					height="300" width="684" 
					alt='美式标准 "101" 键盘所有按键对应的各自所属位置' 
				/>
    		<div class="custom-figcaption">
				美式标准 "101" 键盘所有按键对应的各自所属 {{KeyboardEvent/location}} 值
				</div>
				</figure>

				</div>
				
	
				<dt	class="origin-dfn"><dfn attribute>key</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">key</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					<code>key</code> 保存与所按下按键相对应的 [=键属性值=] 。
	
					<p class="note">
					<code>key</code> 属性与遗留的 <code>keyCode</code> 属性无关，
					并且没有相同的值集。
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是空字符串
					<code>""</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>code</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">code</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					<code>code</code> 保存一个字符串，用于标识正在按下的物理键。
					该值不受当前键盘布局或修饰键状态的影响，
					因此特定物理按键将始终返回相同的值。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是空字符串
					<code>""</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>location</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">location</code></i>，
					<code>unsigned long</code>
					<span class="replacement"> 类型(32位无符号整型)，只读</span>
				</dt>
				
				<dd>
					{{KeyboardEvent/location}} 属性保存上述四个按键位置码(KeyLocationCode)
					之一，它指示按键在设备上的逻辑位置。
	
					此属性 <span class="zh-upper">必须</span> 设置为 DOM_KEY_LOCATION 
					常量之一，以指示按键在设备上的位置。
	
					如果 <a href="#user-agent">用户代理</a> 允许重新映射按键，
					则 <span class="zh-upper">必须</span> 将重新映射的按键的 
					{{KeyboardEvent/location}} 值设置为适合新按键的值。
					例如，如果 CODE{ControlLeft} 键映射到 CODE{KeyQ} 键，则 
					{{KeyboardEvent/location}} 属性 <span class="zh-upper">必须</span> 
					设置为 {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}} 。相反，如果 
					CODE{KeyQ} 键被重新映射到 其中一个 KEYCAP{Control} 键，则 
					{{KeyboardEvent/location}} 属性 <span class="zh-upper">必须</span> 
					设置为 {{KeyboardEvent/DOM_KEY_LOCATION_LEFT}} 或 
					{{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}} 。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>0</code>.
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>ctrlKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">ctrlKey</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					如果 KEYCAP{Control} (control)键修饰符处于活动状态，则为 
					<code>true</code> 。

					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code> 。
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>shiftKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">shiftKey</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					如果shift( KEYCAP{Shift} )键修饰符处于活动状态，则为 
					<code>true</code> 。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code>.
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>altKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">altKey</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					如果 KEYCAP{Alt} (alternative)(或 GLYPH{Option} )键修饰符处于活动状态，
					则为 <code>true</code> 。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code>.
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>metaKey</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">metaKey</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					<code>true</code> if the meta (KEYCAP{Meta}) key modifier was
					active.
					如果meta( KEYCAP{Meta} )键修饰符处于活动状态，则为 <code>true</code>
					。

					<p class="note">
					在Macintosh系统(苹果电脑)上的 GLYPH{Command} ( GLYPH{&#x2318;} )
					键修饰符使用此键修饰符表示。
					</p>
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code>.
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>repeat</dfn></dt>
				<dd>
					如果按键被持续按下，则为 <code>true</code> 。持续按下一个键 
					<span class="zh-upper">必须</span> 导致事件 EVENT{keydown} ，
					EVENT{beforeinput} ， EVENT{input} ，按此触发顺序重复(派发)，
					重复的速率由系统配置决定。对于具有 <em>长按按键(long-key-press)</em> 
					行为的移动设备， {{KeyboardEvent/repeat}} 属性值为 <code>true</code> 
					的第一个按键事件 <span class="zh-upper">必须</span> 用作 
					<em>长按按键(long-key-press)</em> 的指示。为了开启重复效果的按键 
					<span class="zh-upper">必须</span> 被按下的时间长度是依赖配置的
					(由配置决定)。

					<div class="note custom-note" id="custom-reapeat-note">
					<q>Long-key-press行为是一种用户交互行为，
					通常指用户在按下键盘上的某个键时，停留的时间超过了一定的阈值，
					例如超过0.5秒或者1秒。
					这种行为通常被视为用户在积极地与计算机进行交互，而不是简单地按下按键。
					<br/>在计算机图形学和人机交互领域，long-key-press
					行为通常被用于触发一些特定的功能或者操作。例如，在一些文本编辑器中，
					当用户在按下某个键超过一定时间后，会出现一个弹出菜单，
					显示与该键相关的操作选项。在其他应用程序中，
					long-key-press行为则可能被用于执行复制、粘贴、撤销等常见操作。 <br/>
					理解long-key-press行为的关键在于理解其背后的意图和行为逻辑。
					与简单地按下按键不同，long-key-press
					行为通常意味着用户希望执行某些特定的操作，
					而这些操作可能是由计算机系统或者应用程序提供的。因此，理解
					long-key-press行为的含义和用途可以帮助我们更好地使用计算机和应用程序，
					提高我们的生产力和效率。</q> ——  
					<a href="https://yiyan.baidu.com/">文心一言</a>  
					</div>
					
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code>.
				</dd>
	
				<dt	class="origin-dfn"><dfn attribute>isComposing</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">isComposing</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，只读</span>
				</dt>
				
				<dd>
					如果按键事件作为合成会话(composition session)的一部分发生，即在
					EVENT{compositionstart} 事件之后和相应的 EVENT{compositionend} 
					事件之前，则为 <code>true</code> 。
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>false</code>.
				</dd>
	
				<dt><dfn method>getModifierState(keyArg)</dfn></dt>
				<dd>
					使用键值查询修饰键的状态。

					如果它(传入的键值)是修饰键并且修饰键处于激活状态，则返回
					<code>true</code>  ，否则返回 <code>false</code> 。	
	
					<dl class="parameters">
						<dt>DOMString keyArg</dt>
						<dd>
							修饰符键值。有效的 <a href="#modifier-key">修饰键</a> 在 
							[[UIEvents Key]] 中的 [=修饰符键值表格=] 中定义。
	
							<p class="note">
							如果应用程序希望区分左右修饰键，则可以使用键盘事件和 
							{{KeyboardEvent/location}} 来推断此信息。
							</p>

							<div class="note custom-note">
							"修饰按键"，"修饰符按键"，"修饰键"，"修饰符"，这几种不同的说法，
							在本规范的翻译中都表示"修饰符按键"，即"Modifier Keys"，
							有时候也会使用"modifiers"简化表示。它是计算机键盘上的一种特殊键
							(或组合键)，当按下时， 它会临时修改另一个键的正常功能。 <br/>
							常见的修饰键有 KEYCAP{Shift} ，KEYCAP{Alt} ， KEYCAP{Ctrl} 等，
							想要了解修饰符按键的功能定义，可以查阅 [=修饰符按键=] ， 
							想要知晓本方法检查修饰键的状态传入的所有参数，如上述，查阅 
							[=修饰符键值表格=] 。 <br> <code>getModifierState(keyArg)</code> 
							方法不会区分是左修饰符按键还是右修饰符按键被激活，
							这是由传入的参数是修饰符键值(modifier key value)，也就是修饰符
							[=键属性值=] 决定的，因为它不区分按键的左右。除了通过 
							{{KeyboardEvent/location}} 来区分左右修饰键，还可以直接通过键码值 
							{{KeyboardEvent/code}} 来区分。
							</div>
							
						</dd>
					</dl>
				</dd>
			</dl>
	
		<h5 id="idl-keyboardeventinit">KeyboardEventInit</h5>
	
			<pre class="idl">
			dictionary KeyboardEventInit : EventModifierInit {
				DOMString key = "";
				DOMString code = "";
				unsigned long location = 0;
				boolean repeat = false;
				boolean isComposing = false;
			};
			</pre>
	
			<dl dfn-for="KeyboardEventInit">
				<dt class="origin-dfn"><dfn dict-member>key</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">key</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，默认值为""</span>
				</dt>
				
				<dd>
					将所有键盘修饰符(如shift-state)纳入考虑范围在考虑后，将键盘事件
					(KeyboardEvent)对象的 <code>key</code> 属性初始化为表示该键含义的 
					unicode 字符串。该值是按键的最终有效值。如果键不是可打印字符，
					则它应该是 [[UIEvents-Key]] 中定义的键值之一。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>code</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">code</code></i>，
					<code>DOMString</code>
					<span class="replacement"> 类型，默认值为""</span>
				</dt>
				
				<dd>
					忽略键盘布局等任何键盘配置变动，将键盘事件(KeyboardEvent)
					对象的 <code>code</code> 属性初始化为表示为按下的物理键的 unicode 
					字符串。此值应该是[[UIEvents-Code]] 中定义的键码值之一。
				</dd>

				<div class="note custom-note">
				键盘事件对象的键值就是接口中定义的 <code>key</code> 属性值，
				键盘事件的码值就是接口中定义的 <code>code</code> 属性值，
				前者表示按键的含义通常与键入值有关，会因为区域设置有所不同，
				后者表示物理按键的编码，用于标识每个独立的物理按键。在翻译过程中，
				"键值"，"键属性值"，"按键值"都是 <code>key</code> 属性值，即 "key value"
				; "码值"，"键码值"，"码属性值"，"键码属性值"都是 <code>code</code> 
				属性值，即 "code value" 。关于二者的含义以及所表示的值集合，可以参阅 
				<a href="https://mangwu.github.io/uievents-key-cn/">用户界面事件键盘事件
				key 属性值</a> 和 <a href="https://mangwu.github.io/uievents-code-cn/">
				用户界面事件键盘事件 code 属性值</a> 。
				</div>
	
				<dt class="origin-dfn"><dfn dict-member>location</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">location</code></i>，
					<code>unsigned long</code>
					<span class="replacement"> 类型(无符号2字节整型)，默认为 
					<code>0</code> </span>
				</dt>
				
				<dd>
					将键盘事件(KeyboardEvent)对象的 {{KeyboardEvent/location}} 
					属性初始化为以下表示位置的数值常量之一: 
	
					*	{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}} (数值 0)</li>
					*	{{KeyboardEvent/DOM_KEY_LOCATION_LEFT}} (数值 1)</li>
					*	{{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}} (数值 2)</li>
					*	{{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}} (数值 3)</li>
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>repeat</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">repeat</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，默认值为 <code>false</code> </span>
				</dt>
				
				<dd>
					初始化键盘事件(KeyboardEvent)对象的 <code>repeat</code> 属性。
					如果当前键盘事件(KeyboardEvent)被认为是由长时间按下(非规范补充: 见于 
					<a href="#custom-reapeat-note">reapeat属性注释</a> )
					任何单个键引起的类似事件的重复序列的一部分，则该属性应设置为 
					<code>true</code> ，否则为 <code>false</code> 。
				</dd>
	
				<dt class="origin-dfn"><dfn dict-member>isComposing</dfn></dt>
				<dt class="custom-dfn"><i><code class="idl">isComposing</code></i>，
					<code>boolean</code>
					<span class="replacement"> 类型，默认值为 <code>false</code></span>
				</dt>
				
				<dd>
					初始化键盘事件(KeyboardEvent)对象的 <code>isComposing</code> 属性。
					如果正在构建的事件是作为合成序列的一部分发生的，则该属性应设置为 
					<code>true</code> ，否则为 <code>false</code> 。
				</dd>
			</dl>
	
	<div class="warning">
	遗留的键盘事件实现包括三个额外的属性， <code>keyCode</code> 、 
	<code>charCode</code> 和 <code>which</code> 。 <code>keyCode</code> 
	属性表示与计算机键盘上某个特定键关联的数值，而 <code>charCode</code> 
	属性则表示与该键关联的字符的 <abbr title="American Standard Code for
	Information Interchange">ASCII</abbr> 值(可能与<code>keyCode</code>值相同)，
	并且仅适用于生成 <a href="#character-value">字符值</a> 的键。
	
	在实践中， <code>keyCode</code> 和 <code>charCode</code> 在不同的平台上不一致，
	甚至相同的实现在不同的操作系统上或使用不同的本地化都会有区别。
	此规范既没有定义 <code>keyCode</code> 或 <code>charCode</code> 的值，
	也没有定义这两个遗留属性的行为。在符合规范的用户界面事件实现中，
	内容作者可以使用 {{KeyboardEvent/key}} 和 {{KeyboardEvent/code}} 作为替代。
	
	<em>获取更多相关信息，请参阅有关 <a href="#legacy-key-attributes">
	遗留键属性</a> 的资料性性附录。</em>
	</div>
	
	<p class="note">
	为了与现有内容兼容，虚拟键盘，如基于屏幕的输入设备上的软件键盘，
	预计会产生正常范围的键盘事件，即使它们不具有物理键。
	</p>
	
	<p class="note">
	在某些实现或系统配置中，某些按键事件或其按键值可能会被使用中的 
	<a href="#ime">输入法编辑器(IME)</a> 抑制(suppressed)。
	</p>
	
	<h4 id="events-keyboard-key-location">键盘事件键位置</h4>

		{{KeyboardEvent/location}} 属性可用于消除键盘上不同物理键
		(例如，左右 KEYCAP{Shift} 键或物理箭头键与当 KEYCAP{NumLock} 
		关闭时的数字键盘箭头键)生成的 {{KeyboardEvent/key}} 值之间的歧义。
	
		下表定义了键盘上具有多余一个位置的特殊键的有效 {{KeyboardEvent/location}} 
		值: 
	
		++---------------------------------+----------------------------------------------+
		=| {{KeyboardEvent}} .             | 有效 {{KeyboardEvent/location}} 值           |
		 | {{KeyboardEvent/key}}           |                                              |
		 +---------------------------------+----------------------------------------------+
		+| KEY{Shift}, KEY{Control},       | {{KeyboardEvent/DOM_KEY_LOCATION_LEFT}},     |
		 | KEY{Alt}, KEY{Meta}             | {{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}}     |
		 +---------------------------------+----------------------------------------------+
		+| KEY{ArrowDown}, KEY{ArrowLeft}, | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY{ArrowRight}, KEY{ArrowUp}   | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 +---------------------------------+----------------------------------------------+
		+| KEY{End}, KEY{Home},            | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY{PageDown}, KEY{PageUp}      | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 +---------------------------------+----------------------------------------------+
		+| KEY_NOLINK{0}, KEY_NOLINK{1},   | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY_NOLINK{2}, KEY_NOLINK{2},   | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 | KEY_NOLINK{4}, KEY_NOLINK{5},   |                                              |
		 | KEY_NOLINK{6}, KEY_NOLINK{7},   |                                              |
		 | KEY_NOLINK{8}, KEY_NOLINK{9},   |                                              |
		 | KEY_NOLINK{.}, KEY{Enter},      |                                              |
		 | KEY_NOLINK{+}, KEY_NOLINK{-},   |                                              |
		 | KEY_NOLINK{*}, KEY_NOLINK{/}    |                                              |
		++---------------------------------+----------------------------------------------+
	
		对于此表中未列出的所有其他键， {{KeyboardEvent/location}} 属性 
		<span class="zh-upper">必须</span> 始终设置为 
		{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}} 。

		<div class="note custom-note">
		本节规范描述，不同的物理按键生成相同键值时，用 {{KeyboardEvent/location}} 
		属性进行区分的说法可行但是反而难以促进理解(个人观点)。因为通常而言，
		标识物理按键的不是键值，而是码值，用键值来区分按键本身就不合理，其次，
		标准键盘上每个物理按键的 {{KeyboardEvent/location}} 
		是它所在键盘上的物理位置决定的，与键值没有强关联，在梳理按键的
		{{KeyboardEvent/location}} 属性值时，参考在键盘事件接口介绍部分引入的 
		<a href="#keyboard-101-us-location">位置码与键盘布局关系图</a> 即可。		
		</div>
		

	<h4 id="events-keyboard-event-order">键盘事件顺序</h4>
	
		对于任何给定的键，本规范中定义的键盘事件按相对于彼此的固定顺序发生: 
	
		++---+-------------+--------------------------------------------------------+
		=| # | 事件类型    | 注释                                                   |
		 +---+-------------+--------------------------------------------------------+
		+| 1 | keydown     |                                                        |
		+| 2 | beforeinput | <em>(仅适用于能产生 <a href="#character-value">字符值  |
		 |   |             | </a> 的键)</em>                                        |
		+|   |             | <em>与该键相关的任何 <a href="#default-action">默认行为|
		 |   |             | </a> , 例如在 DOM 中插入字符。</em>                    |
		+| 3 | input       | <em>(仅适用于已用于更新了 DOM 的键)</em>               |
		+|   |             | <em>由于按键在一段时间被持续按下而导致的任何事件       |
		 |   |             | (见下文)。</em>                                        |
		+| 4 | keyup       |                                                        |
		++---+-------------+--------------------------------------------------------+
	
		如果按键持续按下，以下事件 <span class="zh-upper">可以</span> 
		以环境配置的速率重复发生:  <!-- and the key should seek
		counseling -->
	
		++---+-------------+---------------------------------------------------+
		=| # | 事件类型    | 注释                                              |
		 +---+-------------+---------------------------------------------------+
		+| 1 | keydown     | <em>({{KeyboardEvent/repeat}} 属性被设置成        |
		 |   |             | <code>true</code>)</em>                           |
		+| 2 | beforeinput | <em>(仅适用于能产生 <a href="#character-value">   |
		 |   |             | 字符值</a> 的键)</em>                             |
		+|   |             | <em>与该键相关的任何 <a href="#default-action">   |
		 |   |             | 默认行为</a> , 例如在 DOM 中插入字符。</em>       |
		+| 3 | input       | <em>(仅适用于已用于更新了 DOM 的键)</em>          |
		++---+-------------+---------------------------------------------------+
	
		<p class="note">
		通常，与任何特定键相关联的任何 <a href="#default-action">默认行为</a> 
		都会在派发 EVENT{keyup} 事件之前完成。这可能会稍微延迟 EVENT{keyup} 
		事件的派发(尽管该延迟难以感知)。
		</p>
	
		键事件的 <a href="#event-target">事件目标</a> 是当前的焦点元素，
		即正在处理键盘活动的元素。这通常是 HTML <code>input</code> 
		元素或可编辑的文本元素，但也 <span class="zh-upper">可以</span> 
		是由  <a href="#host-language">宿主语言</a> 定义的元素，
		用于接受非文本目的的键盘输入，例如加速按键(accelerator key)
		的激活或触发某些其他行为。如果没有合适的焦点元素，则事件目标将是 HTML 
		<a href="#body-element">body元素</a> (如果可用)，否则为
		<a href="#root-element">根元素</a> 。
	
		<p class="note">
		<a href="#event-target">事件目标</a> 可能在不同的按键事件之间发生变化。
		例如，在同一次击键(keystroke)过程中， KEYCAP{Tab} 键的 EVENT{keydown} 
		事件可能与的 EVENT{keyup} 事件具有不同的 
		<a href="#event-target">事件目标</a> 。
	
	<h4 id="events-keyboard-types">键盘事件类型</h4>
	
		<h5 id="event-type-keydown"><dfn>keydown</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>keydown</code></strong>                                                |
			+| 接口             | {{KeyboardEvent}}                                                                    |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 多种: (触发) EVENT{beforeinput} 和 EVENT{input} 事件; 启动                           |
			 |                  | <a href="#text-composition-system">文本合成系统</a> ; (触发) EVENT{blur} 和          |
			 |                  | EVENT{focus} 事件; (触发) EVENT{keypress} 事件 (如果支持);                           |
			 |                  | (执行) <a href="#activation-behavior">激活行为</a> ; (触发)其它事件                  |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 正在处理按键事件的焦点元素，或者如果没有元素焦点，  |
			 |                  |     就是 <a href="#body-element">body元素</a> (如果可用)，否则为                     |
			 |                  |     <a href="#root-element">根元素</a> </li>                                         |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/key}} : 按下的键的键值。</li>                  |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/code}} : 与键在键盘上的物理位置相关联的码      |
			 |                  |     (code)值。</li>                                                                  |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/location}} : 键在设备上的位置。</li>           |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/altKey}} : 如果 KEYCAP{Alt}                    |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/shiftKey}} : 如果 KEYCAP{Shift}                |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/ctrlKey}} : 如果 KEYCAP{Ctrl}                  |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/metaKey}} : 如果 KEYCAP{Meta}                  |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/repeat}} : 如果按键被按下足够长的时间，        |
			 |                  |     以触发按键重复，则为 <code>true</code> ，否则为 <code>false</code> </li>         |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/isComposing}} : 如果键事件作为合成会话         |
			 |                  |     (composition session)的一部分发生，则为 <code>true</code> ，                     |
			 |                  |     否则为 <code>false</code> </li>                                                  |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当按下某个键盘按键时， <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。 EVENT{keydown} 
			事件类型是依赖设备的，它依赖输入设备的功能以及它们在操作系统中的映射方式。
			此事件类型 <span class="zh-upper">必须</span> 在 
			<a href="#key-mapping">键映射</a> 之后生成。此事件类型 
			<span class="zh-upper">必须</span> 在与同一个键关联的 EVENT{beforeinput} 、
			EVENT{input} 和 EVENT{keyup} 事件之前被派发。
	
			EVENT{keydown} 事件的默认行为取决于按键: 
	
			*	如果键与一个字符相关联(也就是键值)，则默认行为 
				<span class="zh-upper">必须</span> 是先派发 EVENT{beforeinput} 事件，
				然后再派发 EVENT{input} 事件。如果键与多个字符相关(例如与宏(macro)
				或某些 <a href="#dead-key">死键</a> 序列相关)，则默认行为
				<span class="zh-upper">必须</span> 是为每个字符分配一组 
				EVENT{beforeinput} / EVENT{input} 事件
	
			*	如果按键与 <a href="#text-composition-system">文本合成系统</a> 
				相关联，则默认行为 <span class="zh-upper">必须</span> 是启动该系统
	
			*	如果键是 KEYCAP{Tab} 键，则默认行为 <span class="zh-upper">必须</span> 
				是将文档焦点从当前焦点元素(如果有)转移到新的焦点元素，如 
				<a href="#events-focusevent">焦点事件类型</a> 中描述的那样				
	
			*	如果键是 KEYCAP{Enter} 或 KEYCAP{&nbsp;} (空格)键，
				并且当前焦点在状态更改(state-changing)元素上，则默认行为 
				<span class="zh-upper">必须</span> 是派发 EVENT{click} 事件，
				如果用户代理支持 EVENT{DOMActivate} 事件类型也会派发一个 
				EVENT{DOMActivate} 事件(请参阅 [[#event-flow-activation]] 
				了解更多详细信息)
	
			如果此事件被取消，则 <span class="zh-upper">不得</span> 
			派发关联的事件类型，并且 <span class="zh-upper">不得</span> 
			执行关联的行为。
	
			<p class="note">
			EVENT{keydown} 和 EVENT{keyup} 事件传统上与能检测到的任何按键相关联，
			而不仅仅是那些产生 <a href="#character-value">字符值</a> 的键。
			</p>
	
		<h5 id="event-type-keyup"><dfn>keyup</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>keyup</code></strong>                                                  |
			+| 接口             | {{KeyboardEvent}}                                                                    |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : 正在处理按键事件的焦点元素，或者如果没有元素焦点，  |
			 |                  |     就是 <a href="#body-element">body元素</a> (如果可用)，否则为                     |
			 |                  |     <a href="#root-element">根元素</a> </li>                                         |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/key}} : 按下的键的键值。                 </li> |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/code}} : 与键在键盘上的物理位置相关联的码      |
			 |                  |     (code)值。</li>                                                                  |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/location}} : 键在设备上的位置。</li>           |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/altKey}} : 如果 KEYCAP{Alt}                    |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/shiftKey}} : 如果 KEYCAP{Shift}                |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/ctrlKey}} : 如果 KEYCAP{Ctrl}                  |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/metaKey}} : 如果 KEYCAP{Meta}                  |
			 |                  |     修饰符处于激活状态，则为 <code>true</code> ，否则为 <code>false</code> </li>     |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/repeat}} : 如果按键被按下足够长的时间，        |
			 |                  |     以触发按键重复，则为 <code>true</code> ，否则为 <code>false</code> </li>         |
			 |                  | <li>{{KeyboardEvent}}.{{KeyboardEvent/isComposing}} : 如果键事件作为合成会话         |
			 |                  |     (composition session)的一部分发生，则为 <code>true</code> ，                     |
			 |                  |     否则为 <code>false</code> </li>                                                  |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			当按键被释放时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。 EVENT{keyup} 
			事件类型是依赖设备的，它依赖输入设备的功能以及它们在操作系统中的映射方式。
			此事件类型 <span class="zh-upper">必须</span> 在 
			<a href="#key-mapping">键映射</a> 之后生成。此事件类型 
			<span class="zh-upper">必须</span> 在 EVENT{keydown} 、 
			EVENT{beforeinput} 和与同一个键关联的 EVENT{input} 事件之后被派发。
	
			<p class="note">
			EVENT{keydown} 和 EVENT{keyup} 事件传统上与能检测到的任何按键相关联，
			而不仅仅是那些产生 <a href="#character-value">字符值</a> 的键。
			</p>

<h3 id="events-compositionevents">Composition Events</h3>
	Composition Events provide a means for inputing text in a supplementary or
	alternate manner than by Keyboard Events, in order to allow the use of
	characters that might not be commonly available on keyboard. For example,
	Composition Events might be used to add accents to characters despite their
	absence from standard US keyboards, to build up logograms of many Asian
	languages from their base components or categories, to select word choices
	from a combination of key presses on a mobile device keyboard, or to convert
	voice commands into text using a speech recognition processor. Refer to
	[[#keys]] for examples on how Composition Events are used in combination
	with keyboard events.
	
	Conceptually, a composition session consists of one EVENT{compositionstart}
	event, one or more EVENT{compositionupdate} events, and one
	EVENT{compositionend} event, with the value of the {{CompositionEvent/data}}
	attribute persisting between each <q>stage</q> of this event chain during
	each session.
	
	<p class="note"><strong>Note:</strong>
	While a composition session is active, keyboard events can be dispatched to
	the DOM if the keyboard is the input device used with the composition
	session. See the EVENT{compositionstart} event details</a> and
	<a href="#keys-IME">IME section</a> for relevent event ordering.
	</p>
	
	Not all <a>IME</a> systems or devices expose the necessary data to the DOM,
	so the active composition string (the <q>Reading Window</q> or <q>candidate
	selection menu option</q>) might not be available through this interface, in
	which case the selection MAY be represented by the <a>empty string</a>.
	
	<h4 id="interface-compositionevent">Interface CompositionEvent</h4>
	
		<p class="intro-dom">Introduced in this specification</p>
	
		The {{CompositionEvent}} interface provides specific contextual
		information associated with Composition Events.
	
		To create an instance of the {{CompositionEvent}} interface,
		use the {{CompositionEvent}} constructor, passing an optional
		{{CompositionEventInit}} dictionary.
	
		<h5 id="idl-compositionevent">CompositionEvent</h5>
	
			<pre class="idl">
			[Exposed=Window]
			interface CompositionEvent : UIEvent {
				constructor(DOMString type, optional CompositionEventInit eventInitDict = {});
				readonly attribute DOMString data;
			};
			</pre>
	
			<dl dfn-for="CompositionEvent">
				<dt	class="origin-dfn"><dfn attribute>data</dfn></dt>
				<dd>
					<code>data</code> holds the value of the characters generated by
					an input method. This MAY be a single Unicode character or a
					non-empty sequence of Unicode characters [[Unicode]]. Characters
					SHOULD be normalized as defined by the Unicode normalization
					form <em>NFC</em>, defined in [[UAX15]]. This
					attribute MAY be the <a>empty string</a>.
	
					该属性的 <a href="#un-initialized-value">未初始化值</a>
					<span class="zh-upper">必须</span> 是
					<code>""</code> (the empty string).
				</dd>
			</dl>
	
		<h5 id="idl-compositioneventinit">CompositionEventInit</h5>
	
			<pre class="idl">
			dictionary CompositionEventInit : UIEventInit {
				DOMString data = "";
			};
			</pre>
	
			<dl dfn-for="CompositionEventInit">
				<dt class="origin-dfn"><dfn dict-member>data</dfn></dt>
				<dd>
					Initializes the <code>data</code> attribute of the
					CompositionEvent object to the characters generated by the IME
					composition.
				</dd>
			</dl>
	
	<h4 id="events-composition-order">Composition Event Order</h4>
	
		<p>The Composition Events defined in this specification MUST occur in the following set order relative to one another:</p>
	
		++---+-------------------+---------------------------------------------+
		=| # | 事件类型          | 注释                                        |
		 +---+-------------------+---------------------------------------------+
		+| 1 | compositionstart  |                                             |
		+| 2 | compositionupdate | Multiple events                             |
		+| 3 | compositionend    |                                             |
		++---+-------------------+---------------------------------------------+
	
	<h4 id="events-composition-handwriting">Handwriting Recognition Systems</h4>
	
		The following example describes a possible sequence of events when
		composing a text passage <q>text</q> with a handwriting recognition
		system, such as on a pen tablet, as modeled using Composition Events.
	
		++---+-------------------+---------------------------+------------------------------+
		=| # | 事件类型          | {{CompositionEvent}}<br/> | 注释                         |
		 |   |                   | {{CompositionEvent/data}} |                              |
		 +---+-------------------+------------o--------------+------------------------------+
		+| 1 | compositionstart  |        <code>""</code>    |                              |
		+|   |                   |                           | <em>User writes word on      |
		 |   |                   |                           | tablet surface</em>          |
		+| 2 | compositionupdate |    <code>"test"</code>    |                              |
		+|   |                   |                           | <em>User rejects first       |
		 |   |                   |                           | word-match suggestion,       |
		 |   |                   |                           | selects different match</em> |
		+| 3 | compositionupdate |    <code>"text"</code>    |                              |
		+| 4 | compositionend    |    <code>"text"</code>    |                              |
		++---+-------------------+----------------------------------------------------------+
	
	<h4 id="events-composition-canceling">Canceling Composition Events</h4>
	
		If a EVENT{keydown} event is canceled then any Composition Events that
		would have fired as a result of that EVENT{keydown} SHOULD not be
		dispatched:
	
		++---+------------+----------------------------------------------------+
		=| # | 事件类型   | 注释                                               |
		 +---+------------+----------------------------------------------------+
		+| 1 | keydown    | The <a>default action</a> is prevented, e.g., by   |
		 |   |            | invoking {{Event/preventDefault()}}.               |
		+|   |            | <em>No Composition Events are dispatched</em>      |
		+| 2 | keyup      |                                                    |
		++---+------------+----------------------------------------------------+
	
		If the initial EVENT{compositionstart} event is canceled then the text
		composition session SHOULD be terminated. Regardless of whether or not
		the composition session is terminated, the EVENT{compositionend} event
		MUST be sent.
	
		++---+------------------+-----------------------------------------------+
		=| # | 事件类型         | 注释                                          |
		 +---+------------------+-----------------------------------------------+
		+| 1 | keydown          |                                               |
		+| 2 | compositionstart | The <a>default action</a> is prevented,       |
		 |   |                  | e.g., by invoking {{Event/preventDefault()}}. |
		+|   |                  | <em>No Composition Events are dispatched</em> |
		+| 3 | compositionend   |                                               |
		+| 4 | keyup            |                                               |
		++---+------------------+-----------------------------------------------+
	
	<h4 id="events-composition-key-events">Key Events During Composition</h4>
	
		During the composition session, EVENT{keydown} and EVENT{keyup} events
		MUST still be sent, and these events MUST have the
		{{KeyboardEvent/isComposing}} attribute set to <code>true</code>.
	
		++---+-------------------+-------------------------------+------------------------------+
		=| # | 事件类型          | {{KeyboardEvent}}<br/>        | 注释                         |
		 |   |                   | {{KeyboardEvent/isComposing}} |                              |
		 +---+-------------------+--------------o----------------+------------------------------+
		+| 1 | keydown           | false                         | This is the key event that   |
		 |   |                   |                               | initiates the composition.   |
		+| 2 | compositionstart  |                               |                              |
		+| 3 | compositionupdate |                               |                              |
		+| 4 | keyup             | true                          |                              |
		+|   | ...               |                               | Any key events sent during   |
		 |   |                   |                               | the composition session MUST |
		 |   |                   |                               | have <code>isComposing</code>|
		 |   |                   |                               | set to <code>true</code>.    |
		+| 5 | keydown           | true                          | This is the key event that   |
		 |   |                   |                               | exits the composition.       |
		+| 6 | compositionend    |                               |                              |
		+| 7 | keyup             | false                         |                              |
		++---+-------------------+-------------------------------+------------------------------+
	
	<h4 id="events-composition-input-events">Input Events During Composition</h4>
	
		During the composition session, the EVENT{compositionupdate} MUST be
		dispatched after the EVENT{beforeinput} is sent, but before the
		EVENT{input} event is sent.
	
		++---+-------------------+-----------------------------------------------+
		=| # | 事件类型          | 注释                                          |
		 +---+-------------------+-----------------------------------------------+
		+| 1 | beforeinput       |                                               |
		+| 2 | compositionupdate |                                               |
		+|   |                   | <em>Any DOM updates occur at this point.</em> |
		+| 3 | input             |                                               |
		++---+-------------------+-----------------------------------------------+
	
		<p class="note">
		Most IMEs do not support canceling updates during a composition session.
		</p>
	
		The EVENT{beforeinput} and EVENT{input} events are sent along with the
		EVENT{compositionupdate} event whenever the DOM is updated as part of
		the composition. Since there are no DOM updates associated with the
		EVENT{compositionend} event, EVENT{beforeinput} and EVENT{input} events
		should not be sent at that time.
	
		++---+-------------------+-----------------------------------------------+
		=| # | 事件类型          | 注释                                          |
		 +---+-------------------+-----------------------------------------------+
		+| 1 | beforeinput       | <em> Canceling this will prevent the DOM      |
		 |   |                   | update and the EVENT{input} event.</em>       |
		+| 2 | compositionupdate |                                               |
		+|   |                   | <em>Any DOM updates occur at this point.</em> |
		+| 3 | input             | <em>Sent only if the DOM was updated.</em>    |
		+| 4 | compositionend    |                                               |
		++---+-------------------+-----------------------------------------------+
	
	<h4 id="events-composition-types">Composition Event Types</h4>
	
		<h5 id="event-type-compositionstart"><dfn>compositionstart</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>compositionstart</code></strong>                                       |
			+| 接口             | {{CompositionEvent}}                                                                 |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 能                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | Start a new composition session when a <a>text composition system</a> is enabled     |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : focused element processing the composition</li>     |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{CompositionEvent}}.{{CompositionEvent/data}} : the original string being       |
			 |                  |     edited, otherwise the <a>empty string</a></li>                                   |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			A <a>user agent</a> MUST dispatch this event when a <a>text
			composition system</a> is enabled and a new composition session is
			about to begin (or has begun, depending on the <a>text composition
			system</a>) in preparation for composing a passage of text. This
			event type is device-dependent, and MAY rely upon the capabilities
			of the text conversion system and how it is mapped into the
			operating system. When a keyboard is used to feed an input method
			editor, this event type is generated after a EVENT{keydown} event,
			but speech or handwriting recognition systems MAY send this event
			type without keyboard events.  Some implementations MAY populate the
			{{CompositionEvent/data}} attribute of the EVENT{compositionstart}
			event with the text currently selected in the document (for editing
			and replacement). Otherwise, the value of the
			{{CompositionEvent/data}} attribute MUST be  the <a>empty string</a>.
	
			This event MUST be dispatched immediately before a <a>text
			composition system</a> begins a new composition session, and before
			the DOM is modified due to the composition process. The default
			action of this event is for the <a>text composition system</a> to
			start a new composition session. If this event is canceled, the
			<a>text composition system</a> SHOULD discard the current
			composition session.
	
			<p class="note">
			Canceling the EVENT{compositionstart} <em>event type</em> is
			distinct from canceling the <a>text composition system</a> itself
			(e.g., by hitting a cancel button or closing an <a>IME</a> window).
			</p>
	
			<p class="note">
			Some IMEs do not support cancelling an in-progress composition
			session (e.g., such as GTK which doesn't presently have such an
			API). In these cases, calling {{Event/preventDefault()}} will not
			stop this event's default action.
			</p>
	
		<h5 id="event-type-compositionupdate"><dfn>compositionupdate</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>compositionupdate</code></strong>                                      |
			+| 接口             | {{CompositionEvent}}                                                                 |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : focused element processing the composition,         |
			 |                  |     <code>null</code> if not accessible</li>                                         |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{CompositionEvent}}.{{CompositionEvent/data}} : the string comprising the       |
			 |                  |     current results of the composition session, which MAY be the <a>empty string</a> |
			 |                  |     if the content has been deleted</li>                                             |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			A <a>user agent</a> SHOULD dispatch this event during a composition
			session when a <a>text composition system</a> updates its active
			text passage with a new character, which is reflected in the string
			in {{CompositionEvent/data}}.
	
			In <a>text composition systems</a> which keep the ongoing
			composition in sync with the input control, the
			EVENT{compositionupdate} event MUST be dispatched before the control
			is updated.
	
			Some <a>text composition systems</a> might not expose this
			information to the DOM, in which case this event will not fire
			during the composition process.
	
			If the composition session is canceled, this event will be fired
			immediately before the EVENT{compositionend} event, and the
			{{CompositionEvent/data}} attribute will be set to the <a>empty
			string</a>.
	
		<h5 id="event-type-compositionend"><dfn>compositionend</dfn></h5>
	
			++------------------+--------------------------------------------------------------------------------------+ event-definition
			=| %                |                                                                                      |
			 +------------------+--------------------------------------------------------------------------------------+
			+| 类型             | <strong><code>compositionend</code></strong>                                         |
			+| 接口             | {{CompositionEvent}}                                                                 |
			+| 同步 / 异步      | 同步                                                                                 |
			+| 冒泡             | 能                                                                                   |
			+| 可信目标对象     | <code>Element</code>                                                                 |
			+| 可取消默认行为   | 否                                                                                   |
			+| 能否从Shadow<br/>| 能                                                                                   |
			 | DOM冒泡传递      |                                                                                      |
			+| 默认行为         | 没有                                                                                 |
			+| 上下文<br/>      | <ul>                                                                                 |
			 | (可信事件)       | <li>{{Event}}.{{Event/target}} : focused element processing the composition</li>     |
			 |                  | <li>{{UIEvent}}.{{UIEvent/view}} : <a><code>Window</code></a></li>                   |
			 |                  | <li>{{UIEvent}}.{{UIEvent/detail}} : <code>0</code></li>                             |
			 |                  | <li>{{CompositionEvent}}.{{CompositionEvent/data}} : the string comprising the final |
			 |                  |     result of the composition session, which MAY be the <a>empty string</a> if the   |
			 |                  |     content has been deleted or if the composition process has been canceled</li>    |
			 |                  | </ul>                                                                                |
			++------------------+--------------------------------------------------------------------------------------+
	
			A <a>user agent</a> MUST dispatch this event when a <a>text
			composition system</a> completes or cancels the current composition
			session, and the EVENT{compositionend} event MUST be dispatched
			after the control is updated.
	
			This event is dispatched immediately after the <a>text composition
			system</a> completes the composition session (e.g., the <a>IME</a>
			is closed, minimized, switched out of focus, or otherwise dismissed,
			and the focus switched back to the <a>user agent</a>).

</section>
