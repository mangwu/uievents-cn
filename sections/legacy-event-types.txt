<section>
<h2 id="legacy-event-types">遗留事件类型</h2>


<em>本节是规范的。以下事件类型已过时淘汰(obsolete)，只能由需要与旧版软件兼容的
<a href="#user-agent">用户代理</a> 实现。</em>

本节的目的是记录这些(遗留)特性的现状及其与规范事件的关系。
对于支持这些(遗留)事件的实现，建议使用本节中提供的定义。

下表提供了本规范中不推荐使用的事件类型的信息概要。
它们被整理在这里是为了(规范的)参考引用和完整性。

++-----------------------------+--------+----------+------------------------------------------+------------------+------------+--------------+------------------------------------------------+ legacy-event-types-list_event-sequence-table
=| 事件类型   			           | 同步 / |  冒泡    | 可信事件目标 							              | DOM 接口	       | 可取消     | 能否从Shadow | 默认行为								                        |
 |							               | 异步	  |  阶段    | 类型					                      		  |					         | 默认行为   |	DOM冒泡传递	 |						 						                        |
 +-----------------------------+----o---+----o-----+--------------------o---------------------+--------o---------+------o-----+------o-------+------------------------------------------------+
+| DOMActivate				         | 同步	  | 冒泡     | <code>Element</code>		           			  | UIEvent			     | 能 		    | 能 		       | 没有                                           |
+| DOMAttrModified			       | 同步	  | 冒泡     | <code>Element</code>		           			  | MutationEvent	   | 不能       | 不能	       | 没有                                           |
+| DOMCharacterDataModified	   | 同步	  | 冒泡     | <code>Text</code>,			           			  | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Comment</code>,				        	  |					         |			      |			         |                                                |
 |							               |		    |		       | <code>ProcessingInstruction</code>		    |					         |			      |		           |                                                |
+| DOMFocusIn				           | 同步	  | 冒泡     | <a><code>Window</code></a>,			        | FocusEvent		   | 不能       | 能 		       | 没有                                           |
 |							               |		    |		       | <code>Element</code></td>				        |					         |			      |		           |                                                |
+| DOMFocusOut				         | 同步	  | 冒泡     | <a><code>Window</code></a>,			        | FocusEvent	     | 不能       | 能 		       | 没有                                           |
 |							               |		    |		       | <code>Element</code></td>				        |					         |			      |		           |                                                |
+| DOMNodeInserted			       | 同步	  | 冒泡     | <code>Element</code>, <code>Attr</code>, | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Text</code>, <code>Comment</code>, |					         |			      |		           |                                                |
 |							               |		    |		       | <code>DocumentType</code>,				        |					         |			      |		           |                                                |
 |							               |		    |		       | <code>ProcessingInstruction</code>		    |					         |			      |		           |                                                |
+| DOMNodeInsertedIntoDocument | 同步	  | 不冒泡   | <code>Element</code>, <code>Attr</code>, | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Text</code>, <code>Comment</code>, |					         |			      |		           |                                                |
 |							               |		    |		       | <code>DocumentType</code>,				        |					         |			      |		           |                                                |
 |							               |		    |		       | <code>ProcessingInstruction</code>	  	  |					         |			      |		           |                                                |
+| DOMNodeRemoved			         | 同步	  | 冒泡     | <code>Element</code>, <code>Attr</code>, | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Text</code>, <code>Comment</code>, |					         |			      |		           |                                                |
 |							               |		    |		       | <code>DocumentType</code>,				        |					         |			      |		           |                                                |
 |							               |		    |		       | <code>ProcessingInstruction</code>	   	  |					         |			      |		           |                                                |
+| DOMNodeRemovedFromDocument  | 同步	  | 不冒泡   | <code>Element</code>, <code>Attr</code>, | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Text</code>, <code>Comment</code>, |					         |			      |		           |                                                |
 |							               |		    |		       | <code>DocumentType</code>,				        |					         |			      |		           |                                                |
 |							               |		    |		       | <code>ProcessingInstruction</code>		    |					         |			      |		           |                                                |
+| DOMSubtreeModified		       | 同步	  | 冒泡     | <a><code>Window</code></a>,			        | MutationEvent	   | 不能       | 不能	       | 没有                                           |
 |							               |		    |		       | <code>Document</code>,					          |					         |			      |		           |                                                |
 |							               |		    |		       | <code>DocumentFragment</code>,			      |					         |			      |		           |                                                |
 |							               |		    |		       | <code>Element</code>, <code>Attr</code>  |					         |			      |		           |                                                |
+| keypress					           | 同步	  | 冒泡     | <code>Element</code>		           			  | KeyboardEvent	   | 能 		    | 能 		       | 多种: 启动 <a href="#text-composition-system"> |
 |							               |		    |		       |										                      |					         |			      |		           | 文本合成系统</a>; (触发) EVENT{blur} 和 		    |
 |							               |		    |		       |										                      |					         |			      |		           | EVENT{focus} 事件; (触发) EVENT{DOMActivate}   |
 |							               |		    |		       |										                      |					         |			      |		           | 事件; (触发)其它事件		                        |
++-----------------------------+--------+----------+------------------------------------------+------------------+------------+--------------+------------------------------------------------+


<h3 id="legacy-uievent-events">遗留 {{UIEvent}} 事件</h3>

	<h4 id="legacy-uievent-event-types">遗留 {{UIEvent}} 事件类型</h4>

		<h5 id="event-type-DOMActivate"><dfn>DOMActivate</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMActivate</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{UIEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在被激活的元素</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			当按钮、链接或其他状态可更改的元素被激活时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。查阅 [[#event-flow-activation]] 以获取更多详细信息。

			<p class="warning" id="DOMActivate-deprecated">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMActivate} 
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型，
			而赞成使用相关的 EVENT{click} 事件类型。为了向后兼容，其他规范
			<span class="zh-upper">可以</span> 定义并维护自己的EVENT{DOMActivate} 
			<a href="#event-type">事件类型</a> 。
			</p>

			<p class="note" id="DOMActivate-click">
			虽然 EVENT{DOMActivate} 和 EVENT{click} 并不完全等同，但 
			EVENT{click} 事件类型的实现行为已经发展到包括 EVENT{DOMActivate} 
			<a href="#event-type">事件类型</a> 设计时考虑的最关键的无障碍
			(accessibility)方面，并得到了更广泛的实现。鼓励内容作者使用 EVENT{click} 
			<a href="#event-type">事件类型</a>，而不是相关的 EVENT{mousedown} 或 
			EVENT{mouseup} <a href="#event-type">事件类型</a>，
			以确保最大程度的可访问性(accessibility)。
			</p>

		支持 EVENT{DOMActivate} <a href="#event-type">事件类型</a> 的实现还 
		<span class="zh-upper">应当</span> 将 EVENT{DOMActivate} 作为与 
		<a href="#activation-trigger">激活触发器</a> 关联的 EVENT{click} 事件的 
		<a href="#default-action">默认行为</a> 进行派发。然而，对于 
		<a href="#activation-trigger">激活触发器</a> 的关联的任何事件，
		这样的实现 <span class="zh-upper">应当</span> 只启动一次相关的 
		<a href="#activation-behavior">激活行为</a> 。

		<div class="note custom-note" id="DOMActivate-and-Click-custom-note">
		经过测试，不同浏览器对于触发 EVENT{DOMActivate} 遗留事件的行为不一样，
		例如在点击a标签链接时，会在a元素上派发 EVENT{click} 事件，连带其默认行为执行
		，火狐浏览器(113.0.2 64位)中连带的默认行为包括触发 EVENT{DOMActivate} 事件，
		而谷歌浏览器(114.0.5735.91(正式版本) (64 位))并不包含。测试例子见 
		<a target="_blank"
		href="https://mangwu.github.io/javascript/ProfessionalJavaScriptForWebDeveloper4/ch17 - 事件（Events）/17.4 事件类型（Event Type）/17.4.1 用户界面事件（UI Events）/17.4.1.3 UIEvent Types/DOMActivate事件（supplement）/DOMActivate and Click.html">
		DOMActivate and Click
		</a> 。
		</div>
		

		<div class="example">
		<p>
		XForms [[XFORMS11]] <span class="zh-upper">必须</span>  支持 
		EVENT{DOMActivate} <a href="#event-type">事件类型</a> ，它预定用 
		<a href="#host-language">宿主语言</a> 实现。
		如果用插件或基于脚本的 XForms 实现要安装在符合本规范的不支持 
		EVENT{DOMActivate} <a href="#event-type">事件类型</a> 规定的原生实现中，
		XForms <a href="#user-agent">用户代理</a> 必须根据合适的 
		<a href="#activation-trigger">激活触发器</a> 合成(synthesize)并派发自己的
		EVENT{DOMActivate} 事件。
		</p>

		<p>
		因此，当 EVENT{click} 事件由符合用户界面事件规范的 
		<a href="#user-agent">用户代理</a> 派发时， XForms 
		<a href="#user-agent">用户代理</a> 必须确定是否合成具有与该 EVENT{click}
		事件的 <a href="#default-action">默认行为</a> 的相关属性相同的
		EVENT{DOMActivate} 事件。适当的提示(Appropriate cues，指 EVENT{click}
		事件的属性)可能有 EVENT{click} 事件是否 <a href="#trusted-events">可信</a>
		，或者其 <a href="#event-target">事件目标</a> 是否注册了 EVENT{DOMActivate}
		的 <a href="#event-listener">事件侦听器</a> 。
		</p>
		</div>

		<p class="note">
		不要在许多 <a href="#user-agent">用户代理</a> 中依赖 EVENT{DOMActivate} 
		的协作(interoperable)支持。相反，应该使用 EVENT{click} 
		<a href="#event-type">事件类型</a> ，因为它被广泛的实现支持，
		并提供更容易访问的(accessible)行为。
		</p>

		<p class="warning">
		此规范中反对(deprecated)使用 EVENT{DOMActivate} 
		<a href="#event-type">事件类型</a> 。
		</p>

	<h4 id="legacy-uievent-event-order">激活(Activation)事件顺序</h4>

		如果 <a href="#user-agent">用户代理</a> 支持 <code>DOMActivate</code> 
		事件，则 <span class="zh-upper">必须</span> 
		按以下相对于彼此的固定顺序被派发: (仅列出有关(pertinent)事件): 
		<a href="#default-action">默认行为</a>
		
        ++---+-------------+---------------------------------------------------+
        =| # | 事件类型    | 注释                                              |
         +---+-------------+---------------------------------------------------+
        +| 1 | click       |                                                   |
        +| 2 | DOMActivate | 如果 <a href="#user-agent">用户代理</a> 支持      |
         |   |             | (此事件)，(则作为 EVENT{click} 事件的)            |
         |   |             | <a href="#default-action">默认行为</a> (被派发);  |
         |   |             | 合成的; <code>isTrusted="true"</code>             |
        +| 3 |             | <em>所有其它( EVENT{click} 事件的)                |
				 |   |             | <a href="#default-action">默认行为</a> ，包括     |
				 |   |             | <a href="#activation-behavior">激活行为</a></em>  |
        ++---+-------------+---------------------------------------------------+

		如果焦点元素是被按键事件激活的，则以下显示了典型的事件序列
		(仅列出有关(pertinent)事件):

        ++---+-------------+---------------------------------------------------+
        =| # | 事件类型    | 注释                                              |
         +---+-------------+---------------------------------------------------+
        +| 1 | keydown     | <span class="zh-upper">必须</span>                |
         |   |             | 是可以激活元素的键，例如 KEYCAP{Enter} 或         |
         |   |             | KEYCAP{&nbsp;&nbsp;} (空格)键，或者元素未被激活   |
        +| 2 | click       | (作为 EVENT{keydown} 事件的)                      |
         |   |             | <a href="#default-action">默认行为</a> (被派发);  |
         |   |             | 合成的; <code>isTrusted="true"</code>             |
        +| 3 | DOMActivate | 如果 <a href="#user-agent">用户代理</a> 支持      |
         |   |             | (此事件)，(则作为 EVENT{click} 事件的)            |
         |   |             | <a href="#default-action">默认行为</a> (被派发);  |
         |   |             | 合成的; <code>isTrusted="true"</code>             |
        +| 4 |             | <em>所有其它( EVENT{click} 事件的)                |
				 |   |             | <a href="#default-action">默认行为</a> ，包括     |
				 |   |             | <a href="#activation-behavior">激活行为</a></em>  |
        ++---+-------------+---------------------------------------------------+
		
		<div class="note custom-note">
		关于 EVENT{DOMActivate} 在现代浏览器中的支持行为，可以查阅 
		EVENT{DOMActivate} 事件介绍中的  
		<a href="#DOMActivate-and-Click-custom-note">非规范注释</a> ，
		其中包含一个测试地址可以验证本节事件序列的正确性。
		</div>

<h3 id="legacy-focusevent-events">遗留 {{FocusEvent}} 事件</h3>

	<h4 id="legacy-focusevent-event-types">遗留 {{FocusEvent}} 事件类型</h4>

		<h5 id="event-type-DOMFocusIn"><dfn>DOMFocusIn</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMFocusIn</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在接收焦点的 <a href="#event-target">事件对象</a> </li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			当 <a href="#event-target">事件对象</a> 接收焦点时 
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。 <a href="#event-target">事件对象</a> 
			<span class="zh-upper">必须</span> 在此事件类型被派发前接收焦点
			此事件类型 <span class="zh-upper">必须</span> 在 EVENT{focus}
			事件类型之后被派发。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMFocusIn}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型，
			而赞成使用相关的 EVENT{focus} 和 EVENT{focusin} 事件类型。
			</p>

		<h5 id="event-type-DOMFocusOut"><dfn>DOMFocusOut</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMFocusOut</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在失去焦点的 <a href="#event-target">事件对象</a> </li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			当 <a href="#event-target">事件对象</a> 失去焦点时，
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。焦点 <span class="zh-upper">必须</span> 在派发此事件之前从 
			<a href="#event-target">事件对象</a> 上丢失(taken)。此事件类型 
			<span class="zh-upper">必须</span> 在 EVENT{blur} 事件类型之后被派发。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMFocusOut}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型，
			而赞成使用相关的 EVENT{blur} 和 EVENT{focusout} 事件类型。
			</p>

	<h4 id="legacy-focusevent-event-order">遗留焦点事件(FocusEvent)事件顺序</h4>

		以下是焦点在元素之间转移时的典型事件序列，包括不推荐使用的 EVENT{DOMFocusIn}
		和 EVENT{DOMFocusOut} 事件。所示的顺序假定最初没有元素被聚焦。

		<div class="note custom-note">
		这里的顺序是 EVENT{focusin} => EVENT{focus} => EVENT{DOMFocusIn} ，
		这种顺序在现代浏览器测试中是 <strong>错误的</strong> ，并且不符合正式规范的
		[[#events-focusevent-event-order]] 中的描述。<br/>实际上 
		<a href="https://github.com/w3c/uievents">源项目</a> 在 2023 年 3 月 10 
		号在 main 和 gh-pages 分支上合入了一个名称为 
		<a href="https://github.com/w3c/uievents/commit/c1d10be0a64f765f5721efd00be3adcf2105e291">
		Reflect the reality for the focus event order</a> 的合入请求，
		该分支请求指出了 <code>event-types</code> 文件(事件类型区域内容)
		中有关焦点事件顺序的错误，并将其更正为正确形式，只不过在本(遗留事件类型)
		区域没有进行更改。
		</div>

        ++---+-------------+---------------------------------------------------+ custom-legacy-focusevent-event-order-list_event-sequence-table
        =|🚫| 事件类型    | 注释                                              |
         +---+-------------+---------------------------------------------------+
        +|   |             | <em>用户转移焦点</em>                             |
        +| 1 | focusin     | 在第一个目标元素接收焦点之前发送                  |
        +| 2 | focus       | 在第一个目标元素收到焦点后发送                    |
        +| 3 | DOMFocusIn  | 如果支持(才派发此事件)                            |
        +|   |             | <em>用户转移焦点</em>                             |
        +| 4 | focusout    | 在第一个目标元素失去焦点之前发送                  |
        +| 5 | focusin     | 在第二个目标元素接收焦点之前发送                  |
        +| 6 | blur        | 在第一个目标元素失去焦点后发送                    |
        +| 7 | DOMFocusOut | 如果支持(才派发此事件)                            |
        +| 8 | focus       | 在第二个目标元素接收焦点后发送                    |
        +| 9 | DOMFocusIn  | 如果支持(才派发此事件)                            |
        ++---+-------------+---------------------------------------------------+
		
		<div class="note custom-note">
		为了帮助理解增加遗留焦点事件后，焦点事件触发的顺序，
		下面自定义了一个在实际实现上的焦点事件触发顺序表，测试网站为
		<a href="https://domeventviewer.com/focus-event-viewer.html">
		https://domeventviewer.com/focus-event-viewer.html</a> 。其中，
		经过测试可以知晓的是火狐浏览器(113.0.2 64位)在用户转移焦点时已经不会触发 
		EVENT{DOMFocusIn} 和 EVENT{DOMFocusOut} 事件了，而谷歌浏览器(114.0.5735.91
		(正式版本) (64 位))可以正常触发。
		</div>
        
				++--------------+-------------+---------------------------------------------------+ custom-real-legacy-focusevent-event-order-list_event-sequence-table
        =|✅非规范表格 | 事件类型    | 注释                                              |
         +-------o------+-------------+---------------------------------------------------+
        +|              |             | <em>用户转移焦点</em>                             |
        +| 1            | focus       | 在第一个目标元素接收焦点之后发送                  |
        +| 2            | focusin     | 紧随 EVENT{focus} 事件发送                        |
        +| 3            | DOMFocusIn  | 如果支持(才派发此事件)                            |
        +|              |             | <em>用户转移焦点</em>                             |
        +| 4            | blur        | 在第一个目标元素失去焦点之后发送                  |
        +| 5            | focusout    | 紧随 EVENT{blur} 事件发送                         |
        +| 6            | DOMFocusOut | 如果支持(才派发此事件)                            |
        +| 7            | focus       | 在第二个目标元素接收焦点后发送                    |
        +| 8            | focusin     | 紧随 EVENT{focus} 事件发送                        |
        +| 9            | DOMFocusIn  | 如果支持(才派发此事件)                            |
        ++--------------+-------------+---------------------------------------------------+

<h3 id="legacy-keyboardevent-events">遗留 {{KeyboardEvent}} 事件</h3>

	EVENT{keypress} 事件是一种，用于捕获按键事件并在按键按下导致的 DOM 
	更新效果作用之前对其进行处理的，传统方式。使用 EVENT{keypress} 
	事件的代码通常依赖于遗留的 {{KeyboardEvent/charCode}} 、 
	{{KeyboardEvent/keyCode}} 和 {{UIEvent/which}} 属性。

	请注意， EVENT{keypress} 事件是特定于按键事件的，并且已被 
	EVENT{beforeinput} 和 EVENT{input} 事件的更通用的事件序列所取代(见 
	[[#events-keyboard-event-order]] )。这些新的 <code>input</code> 
	事件不是特定于键盘操作的，并且可以用于捕获用户输入，而不管原始(触发)源是什么。

	<div class="note custom-note">
	个人理解，使用 EVENT{beforeinput} 和 EVENT{input} 代替键盘事件顺序中的 
	EVENT{keypress} 相当于一种脱离硬件的抽象，它能更好的对虚拟键盘进行处理。
	</div>

	<h4 id="legacy-keyboardevent-event-types">遗留 {{KeyboardEvent}} 事件类型</h4>

		<h5 id="event-type-keypress"><dfn>keypress</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>keypress</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{KeyboardEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>多种: 
						启动 <a href="#text-composition-system">文本合成系统</a>; 
						(触发) EVENT{blur} 和 EVENT{focus} 事件;
						(触发) EVENT{DOMActivate} 事件;
						(触发)其它事件</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
									正在处理按键事件的焦点元素，或者如果没有元素焦点，就是 
									<a href="#body-element">body元素</a> (如果可用)，否则为
									<a href="#root-element">根元素</a> </li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{KeyboardEvent}}.{{UIEvent/which}} :
								按键的遗留数字码</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/charCode}} :
								事件的遗留字符值</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/keyCode}} :
								按键的遗留数字码</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/key}} :
								按下的键的键值。</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/code}} :
								与键在键盘上的物理位置相关联的码(code)值。</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/location}} :
								键在设备上的位置。</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/altKey}} :
								如果 KEYCAP{Alt} 修饰符处于激活状态，则为 <code>true</code> ，
								否则为 <code>false</code> </li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/shiftKey}} :
								如果 KEYCAP{Shift} 修饰符处于激活状态，则为 <code>true</code> ，
								否则为 <code>false</code> </li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/ctrlKey}} :
								如果 KEYCAP{Control} 修饰符处于激活状态，则为 <code>true</code> ，
								否则为 <code>false</code> </li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/metaKey}} :
								如果 KEYCAP{Meta} 修饰符处于激活状态，则为 <code>true</code> ，
								否则为 <code>false</code> </li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/repeat}} :
								<code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/isComposing}} :
								如果键事件作为合成会话(composition session)的一部分发生，则为 
								<code>true</code> ，否则为 <code>false</code> </li>
						</ul>
					</td>
				</tr>
			</table>

			如果 <a href="#user-agent">用户代理</a> 支持，并且当且仅当该键能正常产生  
			<a href="#character-value">字符值</a> 时，则 
			<span class="zh-upper">必须</span> 在按下这个键时派发此事件。
			EVENT{keypress} 事件类型是依赖设备的，
			取决于输入设备的功能以及它们在操作系统中的映射方式。

			此事件类型 <span class="zh-upper">必须</span> 在 
			<a href="#key-mapping">键映射</a> 之后生成。使用 
			<a href="#ime">输入法编辑器</a> 时， <span class="zh-upper">不得</span> 
			派发它。

			如果取消此事件，除了取消 <a href="#default-action">默认行为</a> 外，
			还应阻止 EVENT{input} 事件的触发。

			作者 <span class="zh-upper">应当</span> 使用 EVENT{beforeinput} 
			事件而不是遗留的 EVENT{keypress} 事件。

			<p class="note">
			传统上， EVENT{keypress} 事件与能检测到 
			<a href="#character-value">字符值</a> 的按键而非一个物理键相关联，
			并且在某些配置中可能不适用于所有键。
			</p>

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{keypress} 事件类型，
			但本规范 <a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			在编辑上下文时，作者可以转而使用 EVENT{beforeinput} 事件替代( 
			EVENT{keypress} )。
			</p>

	<h4 id="keypress-event-order">EVENT{keypress} 事件顺序</h4>

		EVENT{keypress} 事件类型 <span class="zh-upper">必须</span> 在 
		EVENT{keydown} 事件之后并且与同一个按键关联的 EVENT{keyup} 事件之前被派发。

		EVENT{keypress} 事件类型 <span class="zh-upper">必须</span> 在 
		EVENT{beforeinput} 事件之后并且与同一个按键关联的 EVENT{input} 
		事件之前被派发。

		以下示例演示了支持 EVENT{keypress} 事件的用户代理们的按键事件序列: 

		<div class="example">
		++---+-------------+------------------------+---------------------+--------------------------------+
		=| # | 事件类型    | {{KeyboardEvent}}<br/> | {{InputEvent}}<br/> | 注释                           |
		 |   |             | {{KeyboardEvent/key}}  | {{InputEvent/data}} |                                |
		 +---+-------------+-----------o------------+----------o----------+--------------------------------+
		+| 1 | keydown     | KEY_NOLINK{a}          |                     |                                |
		+| 2 | beforeinput |                        | GLYPH{a}            |                                |
		+| 3 | keypress    | KEY_NOLINK{a}          |                     |                                |
		+|   |             |                        |                     | <em>与该键相关的任何           |
		 |   |             |                        |                     | <a href="#default-action">     |
		 |   |             |                        |                     | 默认行为</a> , 例如在 DOM      |
		 |   |             |                        |                     | 中插入字符。</em>              |
		+| 4 | input       |                        |                     |                                |
		+| 5 | keyup       | KEY_NOLINK{a}          |                     |                                |
		++---+-------------+------------------------+---------------------+--------------------------------+
		</div>

<h3 id="legacy-mutationevent-events">遗留 {{MutationEvent}} 事件</h3>

	<div class="note custom-note">
	<q>Mutation</q> 在英语中意为突变，在前端领域，它常被指为 DOM 
	元素所经历的变化或渲染的 DOM 元素的状态的变化，{{MutationObserver}}
	的出现取代了废弃的 {{MutationEvent}} 事件。
	</div>
	
	突变和名为突变的事件模块旨在允许文档结构的任何更改进行通知，包括属性、
	文本或名称的修改(modifications)。

	<p class="note">
	与 {{MutationEvent}} 接口关联的任何事件类型都指定为不可取消。
	这源于这样一个事实，即如果因(突变)而发生的事件(resulting event)的取消性
	(cancelation)决定文档变化的可能的发生或不发生，
	那么很难使用现有的会导致文档变动(modifications)的 DOM 接口。
	尽管这仍然是一种希望实现的(desired)功能，但决定将其剩余(left)会更好，
	除非将事务添加到 DOM 中(until the addition of transactions into the DOM)。
	</p>

	DOM 树的许多单个修改(modifications)可以导致多个突变事件被派发。 
	与其努力去指定由于树的每一次可能的修改而导致的一系列突变事件的顺序，
	不如将这些事件的顺序留给实现(去自己决定)。

	<div class="warning">
	<p>
	{{MutationEvent}} 接口是在 DOM Level 2 Events 中引入的，
	但尚未在所有 <a href="#user-agent">用户代理</a> 上被完全且可互用地
	(interoperably)被实现。此外，也有人批评接口的设计带来了性能和实现方面的挑战
	(非规范补充: 这也是后来遗弃 {{MutationEvent}} 而引入 {{MutationObserver}} 
	的原因之一)。
	</p>
	<p>
	DOM4 [[!DOM]] 提供了一种使用 {{MutationObserver}} 接口的新机制，
	该接口以更高性能的方式解决了突变事件处理(solve)的用例。因此，
	本规范描述了突变事件是为了保证遗留行为的参考引用和完整性，
	但 <a href="#deprecates">反对(deprecates)</a> 使用 {{MutationEvent}} 接口。
	</p>
	</div>

	<h4 id="interface-mutationevent">MutationEvent 接口</h4>

		<p class="intro-dom">在 DOM Level 2中引入介绍，但在本规范中已被弃用</p>

		<code>MutationEvent</code> 接口提供与突变事件(Mutation events)
		相关的特定上下文信息。

		要创建 <code>MutationEvent</code> 接口的实例，调用 
		{{Document/createEvent()}} 方法。

		<pre class="idl">
		interface MutationEvent : Event {
		  // 属性更改类型(attrChangeType)
		  const unsigned short MODIFICATION = 1;
		  const unsigned short ADDITION = 2;
		  const unsigned short REMOVAL = 3;

		  readonly attribute Node? relatedNode;
		  readonly attribute DOMString prevValue;
		  readonly attribute DOMString newValue;
		  readonly attribute DOMString attrName;
		  readonly attribute unsigned short attrChange;

		  undefined initMutationEvent();
		};
		</pre>

		<dl dfn-for="MutationEvent" data-noexport>
			<dt><dfn const>MODIFICATION</dfn></dt>
			<dd>
				<code>Attr</code> 已修改到位(in place)。
			</dd>

			<dt><dfn const>ADDITION</dfn></dt>
			<dd>
				<code>Attr</code> 刚刚被添加。
			</dd>

			<dt><dfn const>REMOVAL</dfn></dt>
			<dd>
				<code>Attr</code> 刚刚被移除。
			</dd>

			<dt><dfn attribute class="origin-dfn">relatedNode</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">relatedNode</code></i>，
				<code>Node</code>
				<span class="replacement">类型，只读，可为空</span>
			</dt>
			
			<dd>
				<code>relatedNode</code> <span class="zh-upper">必须</span> 
				用于标识与突变事件相关的次级(secondary)节点。例如，
				如果一个突变事件被派发到一个节点，指示其父节点已经更改了，那么 
				<code>relatedNode</code> 将是更改了的父节点。
				如果一个事件被派发到了一个子树，指示其中的一个节点发生了更改，那么
				<code>relatedNode</code> <span class="zh-upper">必须</span> 
				是那个更改了的节点。在派发的事件是 EVENT{DOMAttrModified} 的情况下，
				它指示被修改、添加或删除的 <code>Attr</code> 节点。
				该属性的  <a href="#un-initialized-value">未初始化值</a>  
				该属性的  <a href="#un-initialized-value">未初始化值</a> 
				<span class="zh-upper">必须</span> 是 <code>null</code> 。
			</dd>

			<dt><dfn attribute class="origin-dfn">prevValue</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">prevValue</code></i>，
				<code>DOMString</code>
				<span class="replacement"> 类型，只读</span>
			</dt>
			
			<dd>
				<code>prevValue</code> 表示 EVENT{DOMAttrModified} 事件中的
				<code>Attr</code> 节点的上一个值和 EVENT{DOMCharacterDataModified} 
				事件中的 <code>CharacterData</code> 节点的上一个值。

				该属性的  <a href="#un-initialized-value">未初始化值</a> 
				<span class="zh-upper">必须</span> 是 <code>""</code> (空字符串)。
			</dd>

			<dt><dfn attribute class="origin-dfn">newValue</dfn></dt>
			<dd>
				<code>newValue</code> 表示 EVENT{DOMAttrModified} 事件中的 
				code>Attr</code> 节点的新值，以及 EVENT{DOMCharacterDataModified} 
				事件中的 <code>CharacterData</code> 节点的新值。

				该属性的  <a href="#un-initialized-value">未初始化值</a> 
				<span class="zh-upper">必须</span> 是 <code>""</code> (空字符串)。
			</dd>

			<dt><dfn attribute class="origin-dfn">attrName</dfn></dt>
			<dd>
				<code>attrName</code> 表示 EVENT{DOMAttrModified} 事件中更改了的 
				<code>Attr</code> 节点的名称。

				该属性的  <a href="#un-initialized-value">未初始化值</a> 
				<span class="zh-upper">必须</span> 是 <code>""</code> (空字符串)。
			</dd>

			<dt><dfn attribute class="origin-dfn">attrChange</dfn></dt>
			<dd>
				<code>attrChange</code> 表示触发的(triggered) EVENT{DOMAttrModified} 
				事件的更改类型。这些值可以是 <code>MODIFICATION</code> 、 
				<code>ADDITION</code> 或 <code>REMOVAL</code> 。

				该属性的  <a href="#un-initialized-value">未初始化值</a> 
				<span class="zh-upper">必须</span> 是 <code>0</code> 。

				<p class="note">
				没有为 attrChange (未初始化值)定义常量值 0 。
				</p>
			</dd>

			<dt><dfn method>initMutationEvent()</dfn></dt>
			<dd>
				初始化 <code>MutationEvent</code> 对象的属性。此方法具有与 
				{{Event/initEvent()}} 相同的行为。

				<dl class="parameters">
					<dt>DOMString typeArg</dt>
					<dd>
						有关此参数的描述，请参阅 {{Event/initEvent()}} 方法。
					</dd>

					<dt>boolean bubblesArg</dt>
					<dd>
						有关此参数的描述，请参阅 {{Event/initEvent()}} 方法。
					</dd>

					<dt>boolean cancelableArg</dt>
					<dd>
						有关此参数的描述，请参阅 {{Event/initEvent()}} 方法。
					</dd>

					<dt>Node? relatedNodeArg</dt>
					<dd>
						指定 {{MutationEvent}}.<code>relatedNode</code> 。
					</dd>

					<dt>DOMString prevValueArg</dt>
					<dd>
					
						指定 {{MutationEvent}}.<code>prevValue</code> 。此值 
						<span class="zh-upper">可以</span> 是 
						<a href="#empty-string">空字符串</a> 。
					</dd>

					<dt>DOMString newValueArg</dt>
					<dd>
						指定 {{MutationEvent}}.<code>newValue</code> 。
						此值 <span class="zh-upper">可以</span> 是 
						<a href="#empty-string">空字符串</a> 。
					</dd>

					<dt>DOMString attrNameArg</dt>
					<dd>
						指定 {{MutationEvent}}.<code>attrName</code> 。
						此值 <span class="zh-upper">可以</span> 是 
						<a href="#empty-string">空字符串</a> 。
					</dd>

					<dt>unsigned short attrChangeArg</dt>
					<dd>
						指定 {{MutationEvent}}.<code>attrChange</code>.
						此值 <span class="zh-upper">可以</span> 是 <code>0</code> 。
					</dd>
				</dl>
			</dd>
		</dl>

	<h4 id="legacy-mutationevent-event-types">遗留 {{MutationEvent}} 事件类型</h4>

		突变事件类型如下所示。

		<h5 id="event-type-DOMAttrModified"><dfn>DOMAttrModified</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMAttrModified</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								属性正在被修改的元素</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								更改了的 <code>Attr</code> 节点的名称</li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								最匹配的 <code>attrChangeType</code> 对应的数字码</li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								被修改、添加或删除的 <code>Attr</code> 节点。</li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								如果 <code>Attr</code> 节点已被添加或修改，则表示属性的新值。
								</li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								如果 <code>Attr</code> 节点已被删除或修改，则表示属性的上一个值。
								</li>
						</ul>
					</td>
				</tr>
			</table>

			在修改了一个 <code>Element</code> 的 <code>Attr.value</code> 
			之后以及在一个 <code>Element</code> 上添加或删除一个 <code>Attr</code> 
			节点之后 <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。
			事件的 <a href="#event-target">事件对象</a>
			<span class="zh-upper">必须</span> 是发生了改变的 <code>Element</code> 
			节点。当 <code>Attr</code> 节点的子节点以不影响 <code>Attr.value</code> 
			值的方式更改时，是否会发生此事件类型取决于实现。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMAttrModified}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMCharacterDataModified"><dfn>DOMCharacterDataModified</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMCharacterDataModified</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Text</code>, <code>Comment</code>, <code>ProcessingInstruction</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								内容正在被修改的对象</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								内容正在被修改的对象的父节点</li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								对象的新值</li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								对象的上一个值</li>
						</ul>
					</td>
				</tr>
			</table>

			修改 <code>CharacterData.data</code> 或 
			<code>ProcessingInstruction.data</code> 之后，
			但节点本身尚未被插入或删除之前 <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">必须</span> 派发此事件。这个事件的 
			<a href="#event-target">事件对象</a> <span class="zh-upper">必须</span> 是
			<code>CharacterData</code> 节点或者 <code>ProcessingInstruction</code> 
			节点。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 
			EVENT{DOMCharacterDataModified} <a href="#event-type">事件类型</a> ，
			但本规范 <a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMNodeInserted"><dfn>DOMNodeInserted</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMNodeInserted</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code>, <code>Attr</code>, <code>Text</code>, 
						<code>Comment</code>, <code>DocumentType</code>,
						<code>ProcessingInstruction</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在被插入的元素</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								已插入节点的父节点，或者在 <code>Attr</code> 节点的情况下为 
								<code>ownerElement</code></li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								<a href="#empty-string">空字符串</a></li>
						</ul>
					</td>
				</tr>
			</table>

			当除了 <code>Attr</code> 节点之外的节点被添加为另一个节点的子节点时。
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件类型。当 <code>Attr</code> 节点已添加到一个 
			<code>Element</code> 节点时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">可以</span> 派发此事件(请参阅下面的 
			<a href="#DOMNodeInserted-attr">注释</a> )。
			此事件 <span class="zh-upper">必须</span> 在插入发生后被派发。
			事件的<a href="#event-target">事件对象</a>
			<span class="zh-upper">必须</span> 是要被插入的节点。

			<p class="note" id="DOMNodeInserted-attr">
			要检测属性插入，请改用 EVENT{DOMAttrModified} 事件类型。
			</p>

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMNodeInserted}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMNodeInsertedIntoDocument">
		<dfn>DOMNodeInsertedIntoDocument</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMNodeInsertedIntoDocument</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>否</td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code>, <code>Attr</code>, <code>Text</code>, 
						<code>Comment</code>, <code>DocumentType</code>,
						<code>ProcessingInstruction</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在被插入的元素</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								已插入节点的父节点，或者在 <code>Attr</code> 节点的情况下为 
								<code>ownerElement</code></li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								<a href="#empty-string">空字符串</a></li>
						</ul>
					</td>
				</tr>
			</table>

			当一个节点被插入到文档中时(可以直接插入该节点，也可以插入包含该节点的子树)
			， <a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。 <a href="#user-agent">用户代理</a> 可以将 <code>Attr</code> 
			节点视为一个 <code>Element</code> 子树的一部分。此事件 
			<span class="zh-upper">必须</span> 在插入发生后被派发。事件的 
			<a href="#event-target">事件对象</a> <span class="zh-upper">必须</span> 
			在插入发生后被派发。 如果节点被直接插入， EVENT{DOMNodeInserted} 事件类型 
			<span class="zh-upper">必须</span> 在此( 
			EVENT{DOMNodeInsertedIntoDocument} )事件类型发生之前被派发。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMNodeInsertedIntoDocument}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMNodeRemoved"><dfn>DOMNodeRemoved</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMNodeRemoved</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code>, <code>Attr</code>, <code>Text</code>, 
						<code>Comment</code>, <code>DocumentType</code>,
						<code>ProcessingInstruction</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正被删除的元素</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								被删除的节点的父节点，或者在 <code>Attr</code> 节点的情况下为 
								<code>ownerElement</code></li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								<a href="#empty-string">空字符串</a></li>
						</ul>
					</td>
				</tr>
			</table>

			当从其父节点删除一个除了 <code>Attr</code> 节点以外的节点时， 
			<a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。当 <code>Attr</code> 节点被它自己的 <code>ownerElement</code> 
			节点删除时，<a href="#user-agent">用户代理</a> 
			<span class="zh-upper">可以</span> 派发此事件(请参阅下面的 
			<a href="#DOMNodeRemoved-attr">注释</a> )。
			此事件 <span class="zh-upper">必须</span> 在移除(removal)发生之前被派发。
			事件的 <a href="#event-target">事件对象</a> 
			<span class="zh-upper">必须</span> 是要被删除的节点。

			<p class="note" id="DOMNodeRemoved-attr">
			要可靠地检测属性的移除(removal)，请改用 EVENT{DOMAttrModified} 事件类型。
			</p>

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMNodeRemoved}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMNodeRemovedFromDocument">
		<dfn>DOMNodeRemovedFromDocument</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMNodeRemovedFromDocument</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>否</td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><code>Element</code>, <code>Attr</code>, <code>Text</code>, 
						<code>Comment</code>, <code>DocumentType</code>,
						<code>ProcessingInstruction</code></td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正被删除的元素</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								被删除的节点的父节点，或者在 <code>Attr</code> 节点的情况下为 
								<code>ownerElement</code></li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								<a href="#empty-string">空字符串</a></li>
						</ul>
					</td>
				</tr>
			</table>

			从一个节点在文档中被删除时(可以直接删除该节点，也可以删除包含该节点的子树)
			， <a href="#user-agent">用户代理</a> <span class="zh-upper">必须</span> 
			派发此事件。 <a href="#user-agent">用户代理</a> 
			<span class="zh-upper">可以</span> 将 <code>Attr</code> 节点视为一个
			<code>Element</code> 子树的一部分。此事件 
			<span class="zh-upper">必须</span> 在移除(removal)发生之前被派发。事件的 
			<a href="#event-target">事件对象</a> <span class="zh-upper">必须</span> 
			是要被删除的节点。如果节点被直接删除， EVENT{DOMNodeRemoved} 事件类型 
			<span class="zh-upper">必须</span> 在此( EVENT{DOMNodeRemovedFromDocument}
			)事件类型之前被派发。

			<p class="note">
			要可靠地检测属性的移除(removal)，请改用 EVENT{DOMAttrModified} 事件类型。
			</p>

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 
			EVENT{DOMNodeRemovedFromDocument} <a href="#event-type">事件类型</a> ，
			但本规范 <a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

		<h5 id="event-type-DOMSubtreeModified"><dfn>DOMSubtreeModified</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>类型</th>
					<td><strong><code>DOMSubtreeModified</code></strong></td>
				</tr>
				<tr>
					<th>接口</th>
					<td>{{MutationEvent}}</td>
				</tr>
				<tr>
					<th>同步 / 异步</th>
					<td>同步</td>
				</tr>
				<tr>
					<th>冒泡</th>
					<td>能 </td>
				</tr>
				<tr>
					<th>可信目标对象</th>
					<td><a><code>Window</code></a>, <code>Document</code>, 
						<code>DocumentFragment</code>, <code>Element</code>, 
						<code>Attr</code>
					</td>
				</tr>
				<tr>
					<th>可取消<br/>默认行为</th>
					<td>否</td>
				</tr>
				<tr>
					<th>能否从Shadow<br/>DOM冒泡传递</th>
					<td>否</td>
				</tr>
				<tr>
					<th>默认行为</th>
					<td>没有</td>
				</tr>
				<tr>
					<th>上下文<br/>(可信事件)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								正在被修改的子树的父节点</li>
							<li>{{MutationEvent}}.<code>attrName</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>attrChange</code> :
								<code>0</code></li>
							<li>{{MutationEvent}}.<code>relatedNode</code> :
								<code>null</code></li>
							<li>{{MutationEvent}}.<code>newValue</code> :
								<a href="#empty-string">空字符串</a></li>
							<li>{{MutationEvent}}.<code>prevValue</code> :
								<a href="#empty-string">空字符串</a></li>
						</ul>
					</td>
				</tr>
			</table>

			这是一个用于通知文档的所有更改的常规事件。
			它可以用来代替更具体的突变(mutation)和名为突变的事件。
			它 <span class="zh-upper">可以</span> 在对文件进行一次修改(modification)
			后被派发，也可以在发生多次更改后由实现自行决定派发。后一种情况通常
			<span class="zh-upper">应当</span> 应用于适应(accommodate)
			同时或快速连续发生多个变化的情况。此事件的目标 
			<span class="zh-upper">必须</span> 是已发生的更改的最底层公共父级。
			此事件 <span class="zh-upper">必须</span> 在突变(mutation(s))
			引起的任何其他(突变)事件发生后被派发。

			<p class="warning">
			为了(规范的)参考引用和完整性，本规范中定义了 EVENT{DOMSubtreeModified}
			<a href="#event-type">事件类型</a> ，但本规范 
			<a href="#deprecates">反对(deprecates)</a> 使用此事件类型。
			</p>

</section>
