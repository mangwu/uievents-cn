<section>
<h2 id="legacy-key-attributes">遗留的按键事件 &amp; 鼠标事件的属性</h2>


<em>本节是不规范的。 以下属性已过时淘汰(obsolete)，
只能由需要与支持这些键盘事件的旧版软件兼容的 <a href="#user-agent">用户代理</a>
实现。</em>

这些功能从未被正式定义，当前的浏览器实现也有很大的不同。
包括脚本库的大量的遗留内容，依赖于对 <a href="#user-agent">用户代理</a> 
进行功能检查后采取相应动作，这意味着任何将这些遗留属性和事件进行形式化
(formalize)的尝试，都存在和修复之或使之有效一样多的破坏风险。
此外，这些属性不适合国际化使用，也不涉及无障碍问题。

因此，本规范没有规范性地定义那些通常已经用于处理键盘输入的事件和属性，
尽管为了与遗留内容兼容，它们 <span class="zh-upper">可以</span> 存在于
<a href="#user-agent">用户代理</a> 中。作者 <span class="zh-upper">应当</span> 
使用 {{KeyboardEvent/key}} 属性，而不是 {{KeyboardEvent/charCode}} 和 
{{KeyboardEvent/keyCode}} 属性。

不管怎样，为了记录这些特性的现状及其与规范的事件和属性的关系，
本节提供了有用的信息性(informative)描述。对于支持这些属性和事件的实现，
建议使用本节中提供的定义。

<h3 id="legacy-UIEvent">遗留的 {{UIEvent}} 补充接口</h3>

	<em>本节不是规范的</em>

	<a href="#user-agent">用户代理</a> 传统上包括 {{UIEvent/which}} 属性，以便 
	{{KeyboardEvent}} 和 {{MouseEvent}} 事件们可以记录补充的(supplemental)
	事件信息。

	<p class="note">
	本规范的早期版本直接在 {{KeyboardEvent}} 和 {{MouseEvent}} 上定义了单独的 
	{{UIEvent/which}} 属性，而不是在 {{UIEvent}} 上定义共享 {{UIEvent/which}} 
	属性。
	</p>

	<h4 id="legacy-interface-UIEvent">UIEvent 接口(补充)</h4>

		部分(partial) {{UIEvent}} 接口是 {{UIEvent}} 接口的信息性扩展，它添加了
		{{UIEvent/which}} 属性。

		<pre class="idl">
		partial interface UIEvent {
		  // The following support legacy user agents
		  readonly attribute unsigned long which;
		};
		</pre>

		<dl dfn-for="UIEvent">
			<dt class="origin-dfn"><dfn attribute>which</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">which</code></i>，
				<code>unsigned long</code>
				<span class="replacement"> 类型(32位无符号整型)，只读</span>
			</dt>
			
			<dd>
				对于 {{MouseEvent}} 事件对象，它包含的值等于存储在 {{MouseEvent/button}} 
				中的值 +1 。<br/> 对于 {{KeyboardEvent}} 事件对象，
				它包含一个与系统和实现相关的数字码(numerical code)，
				表示与按下的键相关的未修饰(unmodified)时的标识符。在大多数情况下，该值与
				{{KeyboardEvent/keyCode}} 相同。
			</dd>
		</dl>

	<h4 id="legacy-dictionary-UIEventInit">UIEventInit 接口(补充)</h4>

		包含对 {{UIEvent}} 中的 {{UIEvent/which}} 支持的浏览器也应将以下成员添加到 
		{{UIEventInit}} 字典中。

		部分(partial) {{UIEventInit}} 字典是 {{UIEventInit}} 字典的信息性扩展，
		它添加了 {{UIEvent/which}} 以初始化对应的 {{UIEvent}} 属性成员。

		<pre class="idl">
		partial dictionary UIEventInit {
		  unsigned long which = 0;
		};
		</pre>

		<dl dfn-for="UIEventInit" data-noexport>
			<dt class="origin-dfn"><dfn dict-member>which</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">which</code></i>，
				<code>unsigned long</code>
				<span class="replacement"> 类型(32位无符号整型)，默认值为 
				<code>0</code> </span>
			</dt>
			
			<dd>
				初始化{{UIEvent}} 的 {{UIEvent/which}} 属性。
			</dd>
		</dl>


<h3 id="legacy-KeyboardEvent">遗留的 {{KeyboardEvent}} 补充接口</h3>

	<em>本节不是规范的</em>

	浏览器对键盘的支持在传统依赖于三个特殊(ad-hoc)属性: {{KeyboardEvent/keyCode}} 
	， {{KeyboardEvent/charCode}} ， 和 {{UIEvent}} 的 {{UIEvent/which}} 。

	这三个属性都返回一个数字码，表示按下的键的某一方面(some aspect): 
	{{KeyboardEvent/keyCode}} 是键本身的索引。 {{KeyboardEvent/charCode}} 
	是字符键的 ASCII 值。 {{UIEvent/which}} 是可用的字符值(同)，否则是键索引
	(通常和 {{KeyboardEvent/keyCode}} 相同)。这些属性的值以及属性的可用性在平台、
	键盘语言和布局、 <a href="#user-agent">用户代理</a>  、
	版本甚至事件类型之间都不一致。

	<div class="note custom-note">
	<q>事件类型之间都不一致</q> 指 {{KeyboardEvent/charCode}} 只在遗留的 
	EVENT{keypress} 事件中有值，其它键盘事件类型中默认为 <code>0</code> ，因为 
	EVENT{keypress} 只会在 DOM 发生更新时触发(即击键确定是一个字符按键，
	而不是功能，修饰，菜单或其它按键)，这能确保按键有对应的字符值，即 
	{{KeyboardEvent/charCode}} 才有效。<br/>此外，现代浏览器的 EVENT{keydown} 和 
	EVENTE{keyup} 的 {{KeyboardEvent/keyCode}} 和 {{UIEvent/which}} 
	属性的值总是相同(即等于键本身的索引)，而在同一次击键中可能触发的 
	EVENT{keypress} 事件的 {{KeyboardEvent/keyCode}} ， {{UIEvent/which}} 总是和 
	{{KeyboardEvent/charCode}} 属性值相同(即等于字符键的 ASCII 值)，
	这就导致了一次击键中 <q>这些属性的值</q> 甚至在 <q>事件类型之间都不一致</q> 
	的情况。可以访问 
	<a href="https://domeventviewer.com/key-event-viewer.html">
	https://domeventviewer.com/key-event-viewer.html</a> 自己测试。
	</div>
	
	<h4 id="legacy-interface-KeyboardEvent">KeyboardEvent 接口(补充)</h4>

		部分(partial) {{KeyboardEvent}} 接口是 {{KeyboardEvent}} 接口的信息性
		(informative)扩展，它添加了 {{KeyboardEvent/charCode}} 和 
		{{KeyboardEvent/keyCode}} 属性。

		部分(partial) {{KeyboardEvent}} 接口可以通过在支持此扩展的实现中调用
		{{Document/createEvent()}} 方法调获得(obtained)。

		<pre class="idl">
		partial interface KeyboardEvent {
		  // The following support legacy user agents
		  readonly attribute unsigned long charCode;
		  readonly attribute unsigned long keyCode;
		};
		</pre>

		<dl dfn-for="KeyboardEvent">
			<dt class="origin-dfn"><dfn attribute>charCode</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">charCode</code></i>，
				<code>unsigned long</code>
				<span class="replacement"> 类型(32位无符号整型)，只读</span>
			</dt>
			
			<dd>
				{{KeyboardEvent/charCode}} 保存一个字符值，在字符输入触发的 
				EVENT{keypress} 事件中有效。该值是该字符的 Unicode 参考数字
				(code point，码点)(即对于可打印(printable)字符，<code>event.charCode = 
				event.key.charCodeAt(0)</code> )。对于 EVENT{keydown} 或 EVENT{keyup}
				事件， {{KeyboardEvent/charCode}} 的值为 <code>0</code> 。
			</dd>

			<dt class="origin-dfn"><dfn attribute>keyCode</dfn></dt>
			<dd>
				{{KeyboardEvent/keyCode}} 保存一个与系统和实现相关的数字码(numerical 
				code)，表示与按下的键相关的未修饰(unmodified)时的标识符。与 
				{{KeyboardEvent/key}} 属性不同，该属性值的集合在本规范中没有规范化的定义
				。通常， {{KeyboardEvent/keyCode}} 的这些值 
				<span class="zh-upper">应当</span> 代表 ASCII [[RFC20]] [[US-ASCII]] 或
				Windows 1252 [[WIN1252]] 中的十进制码点(codepoint)，但 
				<span class="zh-upper">可以</span> 从不同的合适字符集中提取。
				如果实现无法识别键(的 {{KeyboardEvent/keyCode}} )，则使用值 KEYCAP{0} 。

				参见 [[#legacy-key-models]] 获取更多详细信息，以了解如何确定 
				{{KeyboardEvent/keyCode}} 的值。
			</dd>
		</dl>

	<h4 id="legacy-dictionary-KeyboardEventInit">KeyboardEventInit 接口(补充)</h4>

		包含对 {{KeyboardEvent}} 中的 {{KeyboardEvent/keyCode}} 和 
		{{KeyboardEvent/charCode}} 支持的浏览器也应将以下成员添加到 
		{{KeyboardEventInit}} 字典中。

		部分(partial) {{KeyboardEventInit}} 字典是 {{KeyboardEventInit}} 
		字典的信息性扩展，它添加了 {{KeyboardEvent/charCode}} 和 
		{{KeyboardEvent/keyCode}} 以初始化对应的 {{KeyboardEvent}} 属性成员。

		<pre class="idl">
		partial dictionary KeyboardEventInit {
		  // The following support legacy user agents
		  unsigned long charCode = 0;
		  unsigned long keyCode = 0;
		};
		</pre>

		<dl dfn-for="KeyboardEventInit" data-noexport>
			<dt class="origin-dfn"><dfn dict-member>charCode</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">charCode</code></i>，
				<code>unsigned long</code>
				<span class="replacement"> 类型(32位无符号整型)，默认值为 
				<code>0</code> </span>
			</dt>
			
			<dd>
				将 {{KeyboardEvent}} 的 {{KeyboardEvent/charCode}} 
				属性初始化为事件字符的 Unicode 码点(code point)。
				character.
			</dd>

			<dt class="origin-dfn"><dfn dict-member>keyCode</dfn></dt>
			<dt class="custom-dfn"><i><code class="idl">keyCode</code></i>，
				<code>unsigned long</code>
				<span class="replacement"> 类型(32位无符号整型)，默认值为 
				<code>0</code> </span>
			</dt>
			<dd>
				将 {{KeyboardEvent}} 的 {{KeyboardEvent/keyCode}} 
				属性初始化为与系统和实现相关的数字码(numerical code)，
				它表示与按下的键相关的未修饰(unmodified)时的标识符。
			</dd>
		</dl>

<h3 id="legacy-key-models">遗留按键模型</h3>

	<em>本节内容不是规范的</em>

	对于不同的事件类型，不同实现选择暴露(exposed)出的事件属性的值会有区别。
	实现 <span class="zh-upper">可以</span> 选择在 {{KeyboardEvent/keyCode}} 
	属性中公开虚拟键码(key codes)和字符码(character codes)(即 <em>合并模型
	(conflated model)</em> )，或者报告单独的 {{KeyboardEvent/keyCode}} 和 
	{{KeyboardEvent/charCode}} 属性(即 <em>拆分模型(split model)</em> )。

	<h4 id="determine-keydown-keyup-keyCode">如何确定 EVENT{keydown} 和 
	EVENT{keyup} 事件的 {{KeyboardEvent/keyCode}} </h4>

		EVENT{keydown} 或 EVENT{keyup} 事件的 {{KeyboardEvent/keyCode}} 
		计算方式如下:

		*	从操作系统的事件信息中读取虚拟键码(key codes)(如果这些信息可用的话)。

		*	如果输入法编辑器正在处理按键输入，并且事件是 EVENT{keydown} ，则返回229。

		*	如果在没有修饰键的情况下按下输入键会插入数字字符(0-9)，
			则返回该数字字符的 ASCII 码。

		*	如果在没有修饰键的情况下按下输入键会从 a-z 
			字母表范围中选择一个小写字符插入，则返回对应大写字符的 ASCII 码。

		*	如果实现支持操作系统和平台规定的键码转换表，请查找该值。
			如果转换表为给定的输入指定了供选择的(alternate)虚拟键值，则返回指定的值。

		*	如果按键的功能(由实现指定的方式确定)对应于 [[#fixed-virtual-key-codes]] 
			表中一个按键，则返回相应的键码(key code)。

		*	返回从操作系统中获取的虚拟键码(key code)。

		*	如果未找到键码(key code)，则返回0。

	<h4 id="determine-keypress-keyCode">如何确定 EVENT{keypress} 事件的 
	{{KeyboardEvent/keyCode}}</h4>

		EVENT{keypress} 事件的 {{KeyboardEvent/keyCode}} 计算方式如下:

		*	如果实现支持 <em>合并模型(conflated model)</em> ，请将 
			{{KeyboardEvent/keyCode}} 设置为所输入字符的 Unicode 码点(code point)。

		*	如果实现支持 <em>拆分模型(split model)</em> ，设置
			{{KeyboardEvent/keyCode}} 为 0 。
		
		<div class="note custom-note">
		现代浏览器大多是第一种情况，即 EVENT{keypress} 事件的 
		{{KeyboardEvent/keyCode}} 值和 {{KeyboardEvent/charCode}} 一致，
		为输入字符的 Unicode 码点。
		</div>
		

	<h4 id="fixed-virtual-key-codes">Fixed virtual key codes</h4>

		The virtual key codes for the following keys do not usually change with
		keyboard layouts on desktop systems:

		++------------+-------------+-------+
		=| Key        | Virtual Key | Notes |
		 |            | <br/>Code   |       |
		 +------------+------o------+---o---+
		+| Backspace  | 8           |       |
		+| Tab        | 9           |       |
		+| Enter      | 13          |       |
		+| Shift      | 16          |       |
		+| Control    | 17          |       |
		+| Alt        | 18          |       |
		+| CapsLock   | 20          |       |
		+| Escape     | 27          | Esc   |
		+| Space      | 32          |       |
		+| PageUp     | 33          |       |
		+| PageDown   | 34          |       |
		+| End        | 35          |       |
		+| Home       | 36          |       |
		+| ArrowLeft  | 37          |       |
		+| ArrowUp    | 38          |       |
		+| ArrowRight | 39          |       |
		+| ArrowDown  | 40          |       |
		+| Delete     | 46          | Del   |
		++------------+-------------+-------+

	<h4 id="optionally-fixed-virtual-key-codes">Optionally fixed virtual key codes</h4>

		The following punctuation characters MAY change virtual codes between
		keyboard layouts, but reporting these values will likely be more
		compatible with legacy content expecting US-English keyboard layout:

		++------------------------+-----------------+-------------+
		=| Key                    | Character       | Virtual Key |
		 |                        |                 | <br/>Code   |
		 +------------------------+--------o--------+------o------+
		+| Semicolon              | GLYPH{;}        | 186         |
		+| Colon                  | GLYPH{:}        | 186         |
		+| Equals sign            | GLYPH{=}        | 187         |
		+| Plus                   | GLYPH{+}        | 187         |
		+| Comma                  | GLYPH{,}        | 188         |
		+| Less than sign         | GLYPH{&lt;}     | 188         |
		+| Minus                  | GLYPH{-}        | 189         |
		+| Underscore             | GLYPH{_}        | 189         |
		+| Period                 | GLYPH{.}        | 190         |
		+| Greater than sign      | GLYPH{&gt;}     | 190         |
		+| Forward slash          | GLYPH{/}        | 191         |
		+| Question mark          | GLYPH{?}        | 191         |
		+| Backtick               | GLYPH{`}        | 192         |
		+| Tilde                  | GLYPH{~}        | 192         |
		+| Opening squace bracket | GLYPH{[}        | 219         |
		+| Opening curly brace    | GLYPH{{}        | 219         |
		+| Backslash              | GLYPH{\}        | 220         |
		+| Pipe                   | GLYPH{&vert;}   | 220         |
		+| Closing square bracket | GLYPH{]}        | 221         |
		+| Closing curly brace    | GLYPH{&rbrace;} | 221         |
		+| Single quote           | GLYPH{'}        | 222         |
		+| Double quote           | GLYPH{"}        | 222         |
		++------------------------+-----------------+-------------+


</section>
